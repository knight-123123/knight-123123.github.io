---
layout: post
author: zzy
categories: [Algorithms, Programming]
tags: [Algorithms, C++]
---

## 算法模板

### 一、前缀和

#### 1. 定义

前缀和是指给定一个数组，我们预先计算出数组每个位置的前缀和。前缀和数组的第 `i` 个元素表示原始数组前 `i` 个元素的和。前缀和可以通过递推公式来计算：

- 设数组为 `arr`，前缀和数组为 `prefix_sum`，则：
  $$
  prefix\_sum[i] = arr[0] + arr[1] + \dots + arr[i-1]
  $$
  
  或者递推表达式：
  $$
  prefix\_sum[i] = prefix\_sum[i-1] + arr[i-1]
  $$
  

#### 2. 代码模板

```cpp
// 计算前缀和数组
vector<int> prefixSum(const vector<int>& arr) {
    int n = arr.size();
    vector<int> prefix_sum(n + 1, 0); // 初始化前缀和数组，大小为n+1，初始为0
    for (int i = 1; i <= n; i++) {
        prefix_sum[i] = prefix_sum[i - 1] + arr[i - 1]; // 递推计算前缀和
    }
    return prefix_sum;
}

// 计算区间和 [left, right)
int rangeSum(const vector<int>& prefix_sum, int left, int right) {
    return prefix_sum[right] - prefix_sum[left]; // 区间和等于 prefix_sum[right] - prefix_sum[left]
}
```

#### 3. 使用例子

##### 问题：给定一个数组和若干区间，求每个区间的元素和。

**例题：**

给定一个数组 `arr = [1, 2, 3, 4, 5]` 和若干区间 `[1, 3]`，`[0, 2]`，分别求出这些区间的和。

**思路：**

1. 首先计算出数组 `arr` 的前缀和数组。
2. 利用前缀和数组，快速计算出各个区间的和。

##### 代码实现：

```cpp
#include <iostream>
#include <vector>
using namespace std;

// 前缀和函数
vector<int> prefixSum(const vector<int>& arr) {
    int n = arr.size();
    vector<int> prefix_sum(n + 1, 0);
    for (int i = 1; i <= n; i++) {
        prefix_sum[i] = prefix_sum[i - 1] + arr[i - 1];
    }
    return prefix_sum;
}

// 查询区间和
int rangeSum(const vector<int>& prefix_sum, int left, int right) {
    return prefix_sum[right] - prefix_sum[left];
}

int main() {
    // 定义数组
    vector<int> arr = {1, 2, 3, 4, 5};
    
    // 计算前缀和数组
    vector<int> prefix_sum = prefixSum(arr);
    
    // 输出前缀和数组
    cout << "Prefix Sum: ";
    for (int i = 0; i <= arr.size(); i++) {
        cout << prefix_sum[i] << " ";
    }
    cout << endl;

    // 计算区间和
    cout << "Range [1, 3): " << rangeSum(prefix_sum, 1, 3) << endl;  // 输出 5
    cout << "Range [0, 2): " << rangeSum(prefix_sum, 0, 2) << endl;  // 输出 3

    return 0;
}
```



### 二、差分数组

#### 1. 定义

差分数组是一种帮助快速处理区间增量更新的工具。它的核心思想是在原数组的基础上构建一个差分数组，通过在差分数组上做局部修改来实现对原数组的整体区间修改。最终，通过前缀和的方式，可以快速恢复出原数组的值。

- **差分数组构建**：设数组 `arr`，则差分数组 `diff` 满足：
  $$
  diff[i] = arr[i] - arr[i-1]
  $$
  
  通过差分数组，我们可以快速对某个区间 `[l, r]` 进行加减操作。
  
- **更新区间**：要对区间 `[l, r]` 增加某个值 `val`，只需要对差分数组进行两次修改：
  $$
  diff[l] += val
  $$
  
  $$
  diff[r + 1] -= val
  $$

  
  
  这意味着我们在位置 `l` 开始增加 `val`，而在位置 `r + 1` 开始减去 `val`，从而实现对区间 `[l, r]` 的增量修改。
  
- **恢复原数组**：通过累加差分数组，我们可以得到更新后的原始数组。

#### 2. 代码模板

```cpp
// 构建差分数组
vector<int> createDiffArray(const vector<int>& arr) {
    int n = arr.size();
    vector<int> diff(n + 1, 0);
    diff[0] = arr[0];
    for (int i = 1; i < n; i++) {
        diff[i] = arr[i] - arr[i - 1];  // 计算差分
    }
    return diff;
}

// 对区间 [l, r] 增加 val
void incrementRange(vector<int>& diff, int l, int r, int val) {
    diff[l] += val;
    if (r + 1 < diff.size()) {
        diff[r + 1] -= val;  // 在 r+1 处进行减去操作
    }
}

// 根据差分数组恢复原始数组
vector<int> restoreArray(const vector<int>& diff) {
    int n = diff.size();
    vector<int> arr(n - 1, 0);
    arr[0] = diff[0];
    for (int i = 1; i < n - 1; i++) {
        arr[i] = arr[i - 1] + diff[i];  // 累加得到原数组
    }
    return arr;
}
```

#### 3. 使用例子

##### 问题：给定一个数组 `arr = [0, 0, 0, 0, 0]`，要求进行若干次区间加法操作，如对区间 `[1, 3]` 增加 `2`，对区间 `[2, 4]` 增加 `3`，然后输出更新后的数组。

**思路：**

1. 先构建差分数组。
2. 进行若干次区间更新，每次修改差分数组的两个位置。
3. 最后通过差分数组恢复出更新后的原数组。

##### 代码实现：

```cpp
#include <iostream>
#include <vector>
using namespace std;

// 构建差分数组
vector<int> createDiffArray(const vector<int>& arr) {
    int n = arr.size();
    vector<int> diff(n + 1, 0);
    diff[0] = arr[0];
    for (int i = 1; i < n; i++) {
        diff[i] = arr[i] - arr[i - 1];
    }
    return diff;
}

// 对区间 [l, r] 增加 val
void incrementRange(vector<int>& diff, int l, int r, int val) {
    diff[l] += val;
    if (r + 1 < diff.size()) {
        diff[r + 1] -= val;
    }
}

// 根据差分数组恢复原始数组
vector<int> restoreArray(const vector<int>& diff) {
    int n = diff.size();
    vector<int> arr(n - 1, 0);
    arr[0] = diff[0];
    for (int i = 1; i < n - 1; i++) {
        arr[i] = arr[i - 1] + diff[i];
    }
    return arr;
}

int main() {
    // 初始化数组
    vector<int> arr = {0, 0, 0, 0, 0};
    
    // 构建差分数组
    vector<int> diff = createDiffArray(arr);
    
    // 进行区间更新
    incrementRange(diff, 1, 3, 2);  // 区间 [1, 3] 增加 2
    incrementRange(diff, 2, 4, 3);  // 区间 [2, 4] 增加 3
    
    // 恢复原始数组
    vector<int> result = restoreArray(diff);
    
    // 输出更新后的数组
    cout << "Updated Array: ";
    for (int num : result) {
        cout << num << " ";
    }
    cout << endl;
    
    return 0;
}
```



### 三、双指针算法

#### 1. 定义

双指针算法是一种常用于数组、链表等线性数据结构的算法。它通过两个指针同时从不同方向（通常是从数组的两端）或同一方向出发，逐步缩小搜索范围，来解决某些优化问题。双指针主要应用于优化查找和搜索问题，能够有效减少时间复杂度。

#### 2. 双指针的操作方式

双指针的核心在于：
- **初始状态**：两个指针分别指向序列的不同位置，通常是左右两端或者序列开头。
- **移动策略**：根据当前状态，判断移动左指针还是右指针，逐步缩小搜索空间。
- **终止条件**：当两个指针相遇时，搜索结束。

#### 3. 双指针算法框架

```cpp
void twoPointerAlgorithm(vector<int>& data) {
    int left = 0;               // 左指针
    int right = data.size() - 1; // 右指针
    
    while (left < right) {
        // 判断左右指针处的元素，根据条件来移动指针
        if (condition(data[left], data[right])) {
            // 左指针满足条件，进行相应操作
            processLeft(data[left]);
            left++;  // 左指针右移
        } else {
            // 右指针满足条件，进行相应操作
            processRight(data[right]);
            right--; // 右指针左移
        }
    }
}
```

- **`data`**：输入数组或线性结构。
- **`left` 和 `right`**：两个指针，分别从左右两端出发。
- **`condition(data[left], data[right])`**：用于判断哪个指针应该移动。
- **`processLeft()` 和 `processRight()`**：分别处理左指针和右指针处的元素。

#### 4. 优点与局限性

- **优点**：双指针可以通过缩小搜索范围，减少时间复杂度，特别是在需要对数组或链表进行多次遍历的场景下，它常常可以优化为一次遍历，时间复杂度降低为 `O(n)`。
- **局限性**：双指针一般只能应用于有序或特定结构的数据，不适用于完全无序的情况，此外，对于复杂结构的问题，需要确保每次移动指针的条件设计正确，否则可能导致遗漏解。

#### 5. 双指针算法的典型应用：接雨水问题

##### *问题描述*

给定一个整数数组 `height`，该数组表示每个柱子的高度，宽度均为 `1`。下雨之后，按照柱子排列的形状，计算能够接住多少雨水。

**示例：**

输入：`height = [0,1,0,2,1,0,1,3,2,1,2,1]`  
输出：`6`

**解释：**  
根据给定的高度图，下雨后可以接住 `6` 个单位的雨水。

##### *思路解析*

我们可以使用双指针从数组的两端开始向中间移动。左右指针分别记录从左边和右边能遇到的最高的柱子。每次移动较小的一侧，计算该侧能接住的水量。具体步骤如下：

1. **初始化左右指针**：`left` 指向最左端，`right` 指向最右端。
2. **维护左右最大高度**：`leftMax` 和 `rightMax` 分别记录左侧和右侧的最高柱子。
3. **计算水量**：每次移动时，如果当前柱子低于左/右最高高度，说明当前柱子可以接水，计算水量并累加。
4. **移动较小的一侧**：如果左边柱子比右边小，移动左指针，否则移动右指针。

##### *代码实现*

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        if (n == 0) return 0;

        int left = 0, right = n - 1;   // 初始化左右指针
        int leftMax = 0, rightMax = 0; // 记录左右两边的最大高度
        int water = 0;                 // 记录总的存水量

        // 双指针从两端向中间移动
        while (left < right) {
            if (height[left] < height[right]) {
                // 左边柱子较低，处理左侧
                if (height[left] >= leftMax) {
                    leftMax = height[left];  // 更新左侧最大高度
                } else {
                    water += leftMax - height[left];  // 计算存水量
                }
                left++;  // 左指针右移
            } else {
                // 右边柱子较低，处理右侧
                if (height[right] >= rightMax) {
                    rightMax = height[right];  // 更新右侧最大高度
                } else {
                    water += rightMax - height[right];  // 计算存水量
                }
                right--;  // 右指针左移
            }
        }

        return water;  // 返回总存水量
    }
};
```



### 四、最大堆（优先队列）算法

#### 1. 定义

最大堆是一种常见的**优先队列**实现方式，使用堆（Heap）数据结构来维护数据集合。在最大堆中，堆顶元素始终是堆中最大的元素。堆通常被用来解决需要维护动态数据集合的最大值或最小值的问题。

最大堆的核心操作包括：
- **插入元素**：将一个新元素加入堆，维护堆的性质。
- **弹出堆顶元素**：删除并返回当前堆中的最大元素，维护堆的结构。
- **查看堆顶元素**：获取堆中的最大元素。

在C++中，可以使用 `priority_queue` 实现最大堆。默认情况下，`priority_queue` 实现的是最大堆，也可以通过额外的参数实现最小堆。

#### 2. 最大堆算法框架

```cpp
#include <queue>
using namespace std;

void maxHeapAlgorithm() {
    priority_queue<int> maxHeap;  // 定义最大堆

    // 插入元素
    maxHeap.push(10);
    maxHeap.push(5);
    maxHeap.push(20);
    
    // 获取堆顶元素（最大值）
    int maxValue = maxHeap.top();
    
    // 弹出堆顶元素
    maxHeap.pop();
    
    // 输出剩下的最大值
    maxValue = maxHeap.top();
}
```

#### 4. 应用第 K 近障碍物查询

##### *问题描述*

在一个无限大的二维平面上，需要处理多个查询，每个查询在平面上指定一个新的障碍物坐标。要求在每次查询后，返回距离原点第 `k` 近的障碍物距离。如果障碍物数量少于 `k`，返回 `-1`。

**示例：**

输入：
```cpp
queries = [[1,2],[3,4],[2,3],[-3,0]], k = 2
```

输出：
```cpp
[-1, 7, 5, 3]
```

**思路：**

1. 每个障碍物的距离由曼哈顿距离 `|x| + |y|` 给出。
2. 使用**最大堆**维护前 `k` 近的障碍物距离。
3. 当新障碍物的距离小于堆顶元素时，替换堆顶以维持前 `k` 近的障碍物。
4. 如果堆中的元素少于 `k`，返回 `-1`；否则，返回堆顶元素（即第 `k` 近的距离）。

##### *代码实现*

```cpp
#include <vector>
#include <queue>
#include <cmath>
using namespace std;

class Solution {
public:
    vector<int> kthClosestObstacle(int k, vector<vector<int>>& queries) {
        vector<int> results;
        priority_queue<int> maxHeap; // 定义最大堆，用于存储前k近的障碍物距离

        // 处理每一个查询
        for (const auto& query : queries) {
            int x = query[0];
            int y = query[1];
            int distance = abs(x) + abs(y);  // 计算障碍物到原点的曼哈顿距离

            // 如果堆中元素少于k个，直接将当前距离加入堆
            if (maxHeap.size() < k) {
                maxHeap.push(distance);
            } 
            // 如果新距离小于堆顶，替换堆顶（维持堆中前k近的距离）
            else if (distance < maxHeap.top()) {
                maxHeap.pop();
                maxHeap.push(distance);
            }

            // 如果堆中元素少于k个，返回-1；否则返回堆顶元素
            if (maxHeap.size() < k) {
                results.push_back(-1);
            } else {
                results.push_back(maxHeap.top());
            }
        }

        return results;
    }
};
```

#### 5. 思路解析

- **最大堆维护前 `k` 近障碍物**：我们使用最大堆来维护 `k` 个距离原点最近的障碍物。每次查询时，检查当前障碍物距离，如果比堆顶的最大值小，就用它替换堆顶元素。这样，堆中始终保存着前 `k` 近的障碍物。
  
- **处理查询**：对于每个查询，如果障碍物数量少于 `k`，返回 `-1`，否则返回堆顶元素，这就是第 `k` 近的障碍物。



### 五、二分图与匈牙利算法

#### 1. 二分图定义

**二分图**（Bipartite Graph）是一种特殊的图，顶点集可以划分为两个不相交的子集 \( U \) 和 \( V \)，使得图中的每一条边都只连接 \( U \) 中的顶点和 \( V \) 中的顶点，而不存在子集 \( U \) 内部或 \( V \) 内部的边。这意味着二分图中的所有边只在两个不同的子集中连接。二分图常用于解决匹配问题。

**应用**：
- 二分图常用于模型化某些配对问题，例如工作分配、婚姻匹配等问题。

#### 2. 二分图的最大匹配

**最大匹配**是指在一个二分图中，能够匹配的边数最多的一组边的集合。每个顶点至多属于一条匹配边，最大匹配就是能够覆盖最多顶点的匹配。

**增广路径**：是指在当前匹配中能够增加一条匹配边的路径，匈牙利算法通过寻找增广路径来增加匹配。

#### 3. 匈牙利算法的定义

**匈牙利算法**是一种解决**二分图最大匹配**问题的算法。它通过迭代寻找**增广路径**来扩展匹配，直到无法找到更多增广路径为止。

#### 4. 匈牙利算法的一般形式

匈牙利算法可以通过DFS（深度优先搜索）来实现寻找增广路径，或者通过宽度优先搜索（BFS）来进行更高效的优化。

##### 匈牙利算法的基本步骤：

1. **初始化**：对于每一个左侧集合 \( U \) 中的顶点，初始化匹配为空。
2. **寻找增广路径**：从左侧集合中的每一个顶点尝试寻找一条未被匹配的增广路径。
3. **更新匹配**：如果找到增广路径，将沿着路径进行匹配更新，使得匹配边数增加。
4. **重复上述过程**，直到没有新的增广路径为止。

#### 5. 匈牙利算法的代码模板（DFS实现）

```cpp
#include <vector>
#include <cstring>
using namespace std;

class Hungarian {
public:
    Hungarian(int n, int m) : n(n), m(m), adj(n), matchU(n, -1), matchV(m, -1), visited(n, false) {}

    // 添加一条边，表示左侧节点 u 和右侧节点 v 可以配对
    void addEdge(int u, int v) {
        adj[u].push_back(v);
    }

    // 寻找增广路径
    bool dfs(int u) {
        for (int v : adj[u]) {
            if (!visited[v]) {
                visited[v] = true;
                if (matchV[v] == -1 || dfs(matchV[v])) {
                    matchU[u] = v;  // 将 u 与 v 匹配
                    matchV[v] = u;  // 将 v 与 u 匹配
                    return true;
                }
            }
        }
        return false;
    }

    // 匈牙利算法主函数，返回最大匹配数
    int maximumMatching() {
        int result = 0;
        for (int u = 0; u < n; ++u) {
            fill(visited.begin(), visited.end(), false);  // 每次寻找增广路径前都需要重置 visited 数组
            if (dfs(u)) {
                result++;
            }
        }
        return result;
    }

private:
    int n, m;  // n 为左侧集合顶点数，m 为右侧集合顶点数
    vector<vector<int>> adj;  // 邻接表表示二分图
    vector<int> matchU;  // 左侧顶点的匹配点
    vector<int> matchV;  // 右侧顶点的匹配点
    vector<bool> visited;  // 用于标记右侧顶点是否访问过
};
```

#### 6. 匈牙利算法的实现详解

- **`addEdge`**：用于构建二分图，表示左侧顶点 `u` 和右侧顶点 `v` 之间有一条边，表明它们可以配对。
- **`dfs`**：深度优先搜索用于寻找增广路径。如果能通过右侧顶点找到未匹配的路径或通过递归找到另一条增广路径，则更新匹配。
- **`maximumMatching`**：执行匈牙利算法的主函数，每次从左侧集合中的每一个顶点尝试寻找增广路径，成功找到匹配的次数就是最大匹配数。

#### 7. 示例应用：二分图最大匹配问题

```cpp
#include <iostream>
#include <vector>

int main() {
    // 创建一个匈牙利算法实例，左侧顶点数为 3，右侧顶点数为 3
    Hungarian hungarian(3, 3);

    // 添加边，构建二分图
    hungarian.addEdge(0, 0);  // 左侧顶点 0 可以和右侧顶点 0 匹配
    hungarian.addEdge(0, 1);  // 左侧顶点 0 可以和右侧顶点 1 匹配
    hungarian.addEdge(1, 0);  // 左侧顶点 1 可以和右侧顶点 0 匹配
    hungarian.addEdge(1, 2);  // 左侧顶点 1 可以和右侧顶点 2 匹配
    hungarian.addEdge(2, 1);  // 左侧顶点 2 可以和右侧顶点 1 匹配

    // 计算最大匹配数
    int maxMatching = hungarian.maximumMatching();
    std::cout << "最大匹配数: " << maxMatching << std::endl;

    return 0;
}
```

