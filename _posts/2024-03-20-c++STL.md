---
layout: post
title: C++ STL个人总结
categories: [Algorithms, Programming]
tags: [C++, STL]
---

{% raw %}
# **C++ STL个人总结**

## **一、常用容器**

### **1. 向量 `vector`（变长数组）**

#### **1.1 基本概念**

`std::vector` 是 C++ STL 中最常用的序列容器之一，用于存储动态大小的数组。它的底层实现是动态数组，能够在末尾高效地添加元素，同时支持随机访问。

##### **主要特点：**

- 动态扩展容量
- 支持随机访问（时间复杂度 O(1)）
- 在末尾插入和删除元素的时间复杂度为 O(1)
- 在中间或开头插入和删除元素的时间复杂度为 O(n)

##### **头文件：**

```cpp
#include <vector>
```

##### **命名空间：**

```cpp
using namespace std;
```

------

#### **1.2 常用操作**

##### **创建和初始化：**

```cpp
vector<int> v1;                     // 空向量
vector<int> v2(10);                  // 包含 10 个默认值为 0 的元素
vector<int> v3(10, 5);               // 包含 10 个值为 5 的元素
vector<int> v4 = {1, 2, 3, 4, 5};    // 使用列表初始化
vector<int> v5(v4);                  // 拷贝构造
```

##### **遍历方式：**

```cpp
// 传统 for 循环
for (size_t i = 0; i < v4.size(); i++) {
    cout << v4[i] << " ";  // 输出: 1 2 3 4 5
}

// 范围 for 循环
for (auto &val : v4) {
    cout << val << " ";    // 输出: 1 2 3 4 5
}

// 迭代器遍历
for (vector<int>::iterator it = v4.begin(); it != v4.end(); ++it) {
    cout << *it << " ";    // 输出: 1 2 3 4 5
}
```

------

#### **1.3 常用成员函数示例**

##### **容量相关函数**

###### 1. `size()`：返回元素数量

```cpp
int main() {
    vector<int> arr = {1, 2, 3, 4};
    cout << "元素数量: " << arr.size() << endl;  // 输出: 元素数量: 4

    for (int i = 0; i < arr.size(); i++) {
        cout << arr[i] << " ";  // 输出: 1 2 3 4
    }
    cout << endl;
    return 0;
}
```

------

###### 2. `capacity()`：返回分配的存储空间容量

```cpp
int main() {
    vector<int> arr;
    cout << "初始容量: " << arr.capacity() << endl;    // 输出: 初始容量: 0
    arr.push_back(10);
    cout << "插入 1 个元素后的容量: " << arr.capacity() << endl;  // 输出可能为: 1
    arr.push_back(20);
    cout << "插入 2 个元素后的容量: " << arr.capacity() << endl;  // 输出可能为: 2 或 4
    return 0;
}
```

------

###### 3. `empty()`：检查向量是否为空

```cpp
int main() {
    vector<int> arr;
    if (arr.empty()) {
        cout << "向量为空" << endl;  // 输出: 向量为空
    }
    arr.push_back(100);
    if (!arr.empty()) {
        cout << "向量不为空" << endl;  // 输出: 向量不为空
    }
    return 0;
}
```

------

###### 4. `resize(n)`：调整向量大小为 n

```cpp
int main() {
    vector<int> arr = {1, 2, 3};
    arr.resize(5);  // 新增元素为默认值 0
    for (int val : arr) {
        cout << val << " ";  // 输出: 1 2 3 0 0
    }
    cout << endl;

    arr.resize(2);  // 缩小向量
    for (int val : arr) {
        cout << val << " ";  // 输出: 1 2
    }
    cout << endl;
    return 0;
}
```

------

###### 5. `reserve(n)`：预留容量以减少扩容次数

```cpp
int main() {
    vector<int> arr;
    arr.reserve(10);  
    cout << "预留容量后: " << arr.capacity() << endl;  // 输出: 预留容量后: 10
    return 0;
}
```

------

##### **元素访问函数**

###### 6. `operator[]`：访问指定位置元素（不检查越界）

```cpp
int main() {
    vector<int> arr = {10, 20, 30};
    cout << "索引 1 处的元素: " << arr[1] << endl;  // 输出: 20
    return 0;
}
```

------

###### 7. `at()`：访问指定位置元素（检查越界）

```cpp
int main() {
    vector<int> arr = {10, 20, 30};
    try {
        cout << "索引 1 处的元素: " << arr.at(1) << endl;  // 输出: 20
        cout << "索引 3 处的元素: " << arr.at(3) << endl;  // 抛出异常
    } catch (const out_of_range &e) {
        cout << "异常: " << e.what() << endl;  // 输出: 异常: vector::_M_range_check: __n (which is 3) >= this->size() (which is 3)
    }
    return 0;
}
```

------

###### 8. `front()`：返回第一个元素

```cpp
int main() {
    vector<int> arr = {100, 200, 300};
    cout << "第一个元素: " << arr.front() << endl;  // 输出: 100
    return 0;
}
```

------

###### 9. `back()`：返回最后一个元素

```cpp
int main() {
    vector<int> arr = {100, 200, 300};
    cout << "最后一个元素: " << arr.back() << endl;  // 输出: 300
    return 0;
}
```

------

###### 10. `data()`：返回指向底层数组的指针

```cpp
int main() {
    vector<int> arr = {10, 20, 30};
    int* p = arr.data();
    cout << "第一个元素（通过指针访问）: " << *p << endl;  // 输出: 10
    return 0;
}
```

------

#### **1.4 更多使用示例**

##### **反转元素**

```cpp
#include <algorithm>
vector<int> v = {1, 2, 3, 4, 5};
reverse(v.begin(), v.end());
for (auto val : v) cout << val << " ";  // 输出: 5 4 3 2 1
```

------

##### **合并两个 `vector`**

```cpp
vector<int> a = {1, 2, 3};
vector<int> b = {4, 5, 6};
a.insert(a.end(), b.begin(), b.end());
for (auto val : a) cout << val << " ";  // 输出: 1 2 3 4 5 6
```

------

##### **查找元素**

```cpp
#include <algorithm>
vector<int> v = {10, 20, 30, 40};
auto it = find(v.begin(), v.end(), 30);
if (it != v.end())
    cout << "找到元素 30，索引为: " << distance(v.begin(), it) << endl;  // 输出: 索引为 2
else
    cout << "未找到元素 30" << endl;
```

------

#### **1.5 高级用法与技巧**

##### **二分查找（前提：有序向量）**

```cpp
#include <algorithm>
vector<int> v = {10, 20, 30, 40, 50};
if (binary_search(v.begin(), v.end(), 30))
    cout << "找到元素 30" << endl;  // 输出: 找到元素 30
else
    cout << "未找到元素 30" << endl;
```

------

##### **使用 `lower_bound` 和 `upper_bound` 查找范围**

```cpp
#include <algorithm>
vector<int> v = {10, 20, 20, 20, 30, 40};
auto lower = lower_bound(v.begin(), v.end(), 20);  // 第一个 >= 20 的位置
auto upper = upper_bound(v.begin(), v.end(), 20);  // 第一个 > 20 的位置
cout << "20 的数量: " << distance(lower, upper) << endl;  // 输出: 3
```

------

##### **自定义排序规则**

```cpp
#include <algorithm>
vector<pair<int, int>> v = {{1, 3}, {2, 2}, {3, 1}};
sort(v.begin(), v.end(), [](auto &a, auto &b) {
    return a.second < b.second;
});
for (auto &[x, y] : v) cout << "(" << x << "," << y << ") ";  // 输出: (3,1) (2,2) (1,3)
```

------

##### **删除重复元素（结合 `unique` 与 `erase`）**

```cpp
#include <algorithm>
vector<int> v = {1, 2, 2, 3, 3, 3, 4};
v.erase(unique(v.begin(), v.end()), v.end());
for (auto val : v) cout << val << " ";  // 输出: 1 2 3 4
```

------

##### **在 `vector` 中实现堆（priority queue 的底层）**

```cpp
#include <algorithm>
vector<int> v = {10, 40, 30, 20, 50};
make_heap(v.begin(), v.end());
cout << "堆顶元素: " << v.front() << endl;  // 输出: 50
```



### **2. 集合 `set`（有序集合）**

#### **2.1 基本概念**

`std::set` 是 C++ STL 中的关联容器，用于存储**唯一**的元素，且元素会根据键值自动排序（默认按照升序排列）。
 其底层实现为**红黑树**，保证元素有序，并且插入、删除、查找的时间复杂度为 O(log n)。

##### **主要特点：**

- 元素自动排序（默认使用 `<` 运算符升序排序）。
- 元素唯一性（自动去重）。
- 支持高效的查找、插入和删除操作（O(log n)）。
- 不支持随机访问。

##### **头文件：**

```cpp
#include <set>
```

##### **命名空间：**

```cpp
using namespace std;
```

------

#### **2.2 常用操作**

##### **创建和初始化：**

```cpp
set<int> s1;                          // 空集合
set<int> s2 = {4, 2, 5, 1, 3};         // 列表初始化（自动排序）
set<int> s3(s2);                       // 拷贝构造
set<int, greater<int>> s4 = {1, 3, 2}; // 降序排序集合
```

##### **遍历方式：**

```cpp
// 迭代器遍历
for (set<int>::iterator it = s2.begin(); it != s2.end(); ++it) {
    cout << *it << " ";  // 输出: 1 2 3 4 5
}

// 范围 for 循环
for (auto &val : s2) {
    cout << val << " ";  // 输出: 1 2 3 4 5
}

// 逆序遍历
for (auto it = s2.rbegin(); it != s2.rend(); ++it) {
    cout << *it << " ";  // 输出: 5 4 3 2 1
}
```

------

#### **2.3 常用成员函数示例**

##### **容量相关函数**

###### 1. `size()`：返回元素数量

```cpp
int main() {
    set<int> s = {1, 2, 3, 4};
    cout << "元素数量: " << s.size() << endl;  // 输出: 元素数量: 4
    return 0;
}
```

------

###### 2. `empty()`：检查集合是否为空

```cpp
int main() {
    set<int> s;
    if (s.empty()) cout << "集合为空" << endl;  // 输出: 集合为空
    s.insert(10);
    if (!s.empty()) cout << "集合不为空" << endl;  // 输出: 集合不为空
    return 0;
}
```

------

##### **元素访问函数**

###### 3. `find(val)`：查找元素，返回指向元素的迭代器，若未找到返回 `end()`

```cpp
int main() {
    set<int> s = {10, 20, 30};
    auto it = s.find(20);
    if (it != s.end()) cout << "找到元素: " << *it << endl;  // 输出: 找到元素: 20
    else cout << "未找到元素" << endl;
    return 0;
}
```

------

###### 4. `count(val)`：返回元素的数量（对于 `set`，结果为 0 或 1）

```cpp
int main() {
    set<int> s = {10, 20, 30};
    cout << "元素 20 出现次数: " << s.count(20) << endl;  // 输出: 1
    cout << "元素 40 出现次数: " << s.count(40) << endl;  // 输出: 0
    return 0;
}
```

------

##### **修改操作函数**

###### 5. `insert(val)`：插入元素（若元素已存在，则不插入）

```cpp
int main() {
    set<int> s = {10, 20};
    s.insert(30);
    s.insert(20);  // 已存在，不插入
    for (auto val : s) cout << val << " ";  // 输出: 10 20 30
    return 0;
}
```

------

###### 6. `erase(val)`：删除指定元素

```cpp
int main() {
    set<int> s = {10, 20, 30};
    s.erase(20);
    for (auto val : s) cout << val << " ";  // 输出: 10 30
    return 0;
}
```

------

###### 7. `clear()`：清空集合

```cpp
int main() {
    set<int> s = {10, 20, 30};
    s.clear();
    cout << "清除后元素数量: " << s.size() << endl;  // 输出: 清除后元素数量: 0
    return 0;
}
```

------

###### 8. `swap()`：与另一个集合交换元素

```cpp
int main() {
    set<int> s1 = {1, 2, 3};
    set<int> s2 = {4, 5, 6};
    s1.swap(s2);
    for (auto val : s1) cout << val << " ";  // 输出: 4 5 6
    return 0;
}
```

------

##### **范围相关函数**

###### 9. `lower_bound(val)`：返回指向第一个不小于 val 的元素的迭代器

```cpp
int main() {
    set<int> s = {10, 20, 30, 40};
    auto it = s.lower_bound(25);
    cout << "lower_bound(25): " << *it << endl;  // 输出: 30
    return 0;
}
```

------

###### 10. `upper_bound(val)`：返回指向第一个大于 val 的元素的迭代器

```cpp
int main() {
    set<int> s = {10, 20, 30, 40};
    auto it = s.upper_bound(30);
    cout << "upper_bound(30): " << *it << endl;  // 输出: 40
    return 0;
}
```

------

#### **2.4 更多使用示例**

##### **1. 自定义排序规则**

```cpp
#include <set>
#include <iostream>
using namespace std;

int main() {
    set<int, greater<int>> s = {10, 20, 30};
    for (auto val : s) cout << val << " ";  // 输出: 30 20 10
    return 0;
}
```

------

##### **2. 判断元素是否存在**

```cpp
set<int> s = {10, 20, 30};
if (s.find(25) != s.end()) cout << "存在" << endl;
else cout << "不存在" << endl;  // 输出: 不存在
```

------

##### **3. 合并两个集合**

```cpp
set<int> s1 = {1, 3, 5};
set<int> s2 = {2, 3, 4};
s1.insert(s2.begin(), s2.end());
for (auto val : s1) cout << val << " ";  // 输出: 1 2 3 4 5
```

------

##### **4. 使用 `set` 实现去重**

```cpp
vector<int> nums = {1, 2, 2, 3, 4, 4, 5};
set<int> s(nums.begin(), nums.end());
for (auto val : s) cout << val << " ";  // 输出: 1 2 3 4 5
```

------

##### **5. 统计范围内元素数量**

```cpp
set<int> s = {10, 20, 30, 40, 50};
auto start = s.lower_bound(20);
auto end = s.upper_bound(40);
cout << "范围内元素数量: " << distance(start, end) << endl;  // 输出: 3
```

------

#### **2.5 高级用法与技巧**

##### **1. 自定义数据类型的排序规则**

```cpp
#include <set>
#include <iostream>
using namespace std;

struct Person {
    string name;
    int age;
    bool operator<(const Person &p) const { return age < p.age; }
};

int main() {
    set<Person> people = {{"Alice", 30}, {"Bob", 25}, {"Charlie", 35}};
    for (auto &p : people) cout << p.name << " - " << p.age << endl;
    // 输出:
    // Bob - 25
    // Alice - 30
    // Charlie - 35
    return 0;
}
```

------

##### **2. 查找区间元素**

```cpp
set<int> s = {10, 20, 30, 40, 50};
auto it1 = s.lower_bound(20);  // 第一个 >= 20 的位置
auto it2 = s.upper_bound(40);  // 第一个 > 40 的位置
for (auto it = it1; it != it2; ++it) cout << *it << " ";  // 输出: 20 30 40
```

------

##### **3. 使用 `set` 处理唯一子序列问题**

```cpp
string str = "programming";
set<char> unique_chars(str.begin(), str.end());
for (auto c : unique_chars) cout << c << " ";  // 输出: a g i m n o p r
```

------

##### **4. 快速合并和交集**

```cpp
#include <set>
#include <algorithm>
set<int> s1 = {1, 2, 3, 4};
set<int> s2 = {3, 4, 5, 6};
set<int> intersect;

set_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(), inserter(intersect, intersect.begin()));
for (auto val : intersect) cout << val << " ";  // 输出: 3 4
```



### **3. 映射 `map`（有序关联容器）**

#### **3.1 基本概念**

`std::map` 是 C++ STL 中的关联容器，用于存储**键值对 (key-value)**，并且**键具有唯一性**。
 它会根据键值自动排序（默认使用 `<` 运算符升序排列），底层实现为**红黑树**，保证插入、删除、查找的时间复杂度为 O(log n)。

##### **主要特点：**

- 存储唯一的键值对 (key-value)。
- 自动按键排序（默认按键升序）。
- 键的插入、删除、查找操作时间复杂度为 O(log n)。
- 支持通过 `[]` 运算符访问和插入元素。

##### **头文件：**

```cpp
#include <map>
```

##### **命名空间：**

```cpp
using namespace std;
```

------

#### **3.2 常用操作**

##### **创建和初始化：**

```cpp
map<int, string> m1;                          // 空map
map<int, string> m2 = {{1, "one"}, {2, "two"}}; // 列表初始化
map<int, string> m3(m2);                      // 拷贝构造
map<int, string, greater<int>> m4;            // 降序排序
```

------

##### **遍历方式：**

```cpp
map<int, string> m = {{3, "three"}, {1, "one"}, {2, "two"}};

// 使用迭代器遍历
for (map<int, string>::iterator it = m.begin(); it != m.end(); ++it) {
    cout << it->first << ": " << it->second << endl;
    // 输出:
    // 1: one
    // 2: two
    // 3: three
}

// 使用范围 for 循环
for (auto &p : m) {
    cout << p.first << ": " << p.second << endl;  // 同上
}
```

------

#### **3.3 常用成员函数示例**

##### **容量相关函数**

###### 1. `size()`：返回元素数量

```cpp
int main() {
    map<int, string> m = {{1, "one"}, {2, "two"}};
    cout << "元素数量: " << m.size() << endl;  // 输出: 2
    return 0;
}
```

------

###### 2. `empty()`：检查映射是否为空

```cpp
int main() {
    map<int, string> m;
    if (m.empty()) cout << "map 为空" << endl;  // 输出: map 为空
    m[1] = "one";
    if (!m.empty()) cout << "map 不为空" << endl;  // 输出: map 不为空
    return 0;
}
```

------

##### **元素访问函数**

###### 3. `operator[]`：访问或插入指定键的元素

```cpp
int main() {
    map<int, string> m;
    m[1] = "one";  // 插入键值对
    cout << "键 1 对应的值: " << m[1] << endl;  // 输出: one
    return 0;
}
```

------

###### 4. `at(key)`：访问指定键的元素（若键不存在会抛出异常）

```cpp
int main() {
    map<int, string> m = {{1, "one"}};
    cout << m.at(1) << endl;  // 输出: one

    try {
        cout << m.at(2) << endl;  // 抛出 out_of_range 异常
    } catch (out_of_range &e) {
        cout << "异常: " << e.what() << endl;  // 输出异常信息
    }
    return 0;
}
```

------

##### **查找与判断函数**

###### 5. `find(key)`：查找键，返回迭代器

```cpp
int main() {
    map<int, string> m = {{1, "one"}, {2, "two"}};
    auto it = m.find(2);
    if (it != m.end()) cout << "找到: " << it->second << endl;  // 输出: two
    else cout << "未找到" << endl;
    return 0;
}
```

------

###### 6. `count(key)`：返回键出现次数（map 中为 0 或 1）

```cpp
int main() {
    map<int, string> m = {{1, "one"}};
    cout << "键 1 出现次数: " << m.count(1) << endl;  // 输出: 1
    cout << "键 2 出现次数: " << m.count(2) << endl;  // 输出: 0
    return 0;
}
```

------

##### **修改操作函数**

###### 7. `insert()`：插入元素

```cpp
int main() {
    map<int, string> m;
    m.insert({1, "one"});
    m.insert(make_pair(2, "two"));
    for (auto &p : m) cout << p.first << ": " << p.second << endl;
    // 输出:
    // 1: one
    // 2: two
    return 0;
}
```

------

###### 8. `erase(key)`：删除指定键的元素

```cpp
int main() {
    map<int, string> m = {{1, "one"}, {2, "two"}};
    m.erase(1);
    for (auto &p : m) cout << p.first << ": " << p.second << endl;  // 输出: 2: two
    return 0;
}
```

------

###### 9. `clear()`：清空映射

```cpp
int main() {
    map<int, string> m = {{1, "one"}, {2, "two"}};
    m.clear();
    cout << "清除后元素数量: " << m.size() << endl;  // 输出: 0
    return 0;
}
```

------

###### 10. `swap()`：交换两个映射

```cpp
int main() {
    map<int, string> m1 = {{1, "one"}};
    map<int, string> m2 = {{2, "two"}};
    m1.swap(m2);
    for (auto &p : m1) cout << p.first << ": " << p.second << endl;  // 输出: 2: two
    return 0;
}
```

------

##### **范围相关函数**

###### 11. `lower_bound(key)`：返回指向第一个不小于 key 的元素

```cpp
int main() {
    map<int, string> m = {{10, "ten"}, {20, "twenty"}, {30, "thirty"}};
    auto it = m.lower_bound(15);
    cout << "lower_bound(15): " << it->first << ": " << it->second << endl;  // 输出: 20: twenty
    return 0;
}
```

------

###### 12. `upper_bound(key)`：返回指向第一个大于 key 的元素

```cpp
int main() {
    map<int, string> m = {{10, "ten"}, {20, "twenty"}, {30, "thirty"}};
    auto it = m.upper_bound(20);
    cout << "upper_bound(20): " << it->first << ": " << it->second << endl;  // 输出: 30: thirty
    return 0;
}
```

------

#### **3.4 更多使用示例**

##### **1. 遍历并修改元素**

```cpp
map<int, int> m = {{1, 10}, {2, 20}, {3, 30}};
for (auto &p : m) p.second *= 2;
for (auto &p : m) cout << p.first << ": " << p.second << endl;  
// 输出:
// 1: 20
// 2: 40
// 3: 60
```

------

##### **2. 按值排序的 map（使用 vector + sort 实现）**

```cpp
#include <algorithm>
#include <vector>
map<int, string> m = {{1, "c"}, {2, "a"}, {3, "b"}};
vector<pair<int, string>> v(m.begin(), m.end());
sort(v.begin(), v.end(), [](auto &a, auto &b) { return a.second < b.second; });
for (auto &p : v) cout << p.first << ": " << p.second << endl;
// 输出:
// 2: a
// 3: b
// 1: c
```

------

##### **3. 合并两个 map**

```cpp
map<int, string> m1 = {{1, "one"}, {2, "two"}};
map<int, string> m2 = {{2, "deux"}, {3, "three"}};
m1.insert(m2.begin(), m2.end());
for (auto &p : m1) cout << p.first << ": " << p.second << endl;
// 输出:
// 1: one
// 2: two  (保留 m1 中原值)
// 3: three
```

------

##### **4. 使用自定义类型作为键**

```cpp
struct Point {
    int x, y;
    bool operator<(const Point &p) const { return x == p.x ? y < p.y : x < p.x; }
};

map<Point, string> points;
points[{1, 2}] = "A";
points[{1, 3}] = "B";
for (auto &p : points) cout << "(" << p.first.x << "," << p.first.y << "): " << p.second << endl;
// 输出:
// (1,2): A
// (1,3): B
```

------

#### **3.5 高级用法与技巧**

##### **1. 自定义排序规则（降序）**

```cpp
map<int, string, greater<int>> m = {{1, "one"}, {2, "two"}, {3, "three"}};
for (auto &p : m) cout << p.first << ": " << p.second << endl;
// 输出:
// 3: three
// 2: two
// 1: one
```

------

##### **2. 使用 `map` 实现词频统计**

```cpp
#include <map>
#include <string>
#include <sstream>
string text = "apple banana apple orange banana apple";
map<string, int> freq;
istringstream iss(text);
string word;
while (iss >> word) freq[word]++;
for (auto &p : freq) cout << p.first << ": " << p.second << endl;
// 输出:
// apple: 3
// banana: 2
// orange: 1
```

------

##### **3. 统计键在范围内的元素**

```cpp
map<int, string> m = {{10, "ten"}, {20, "twenty"}, {30, "thirty"}, {40, "forty"}};
auto start = m.lower_bound(15);
auto end = m.upper_bound(35);
for (auto it = start; it != end; ++it) cout << it->first << ": " << it->second << endl;
// 输出:
// 20: twenty
// 30: thirty
```



### **4. 栈 `stack`（后进先出容器）**

#### **4.1 基本概念**

`std::stack` 是 C++ STL 中的一种容器适配器，遵循**后进先出 (LIFO, Last In First Out)** 的数据结构。
 `stack` 通过封装其他序列容器（如 `deque`、`vector` 或 `list`）实现，默认底层容器为 `deque`。

##### **主要特点：**

- 后进先出：最后插入的元素最先被移除。
- 只允许在栈顶进行插入和删除操作。
- 不支持随机访问。
- 底层默认使用 `deque`，也可指定为 `vector` 或 `list`。

##### **头文件：**

```cpp
#include <stack>
```

##### **命名空间：**

```cpp
using namespace std;
```

------

#### **4.2 常用操作**

##### **创建和初始化：**

```cpp
stack<int> s1;                      // 空栈
stack<int, vector<int>> s2;          // 使用 vector 作为底层容器
stack<int> s3(s1);                   // 拷贝构造
```

------

##### **遍历方式（间接通过出栈访问）：**

```cpp
stack<int> s;
s.push(1);
s.push(2);
s.push(3);

// 通过出栈遍历
while (!s.empty()) {
    cout << s.top() << " ";  // 输出: 3 2 1
    s.pop();
}
cout << endl;
```

------

#### **4.3 常用成员函数示例**

##### **容量相关函数**

###### 1. `size()`：返回栈中元素数量

```cpp
int main() {
    stack<int> s;
    s.push(10);
    s.push(20);
    cout << "元素数量: " << s.size() << endl;  // 输出: 2
    return 0;
}
```

------

###### 2. `empty()`：检查栈是否为空

```cpp
int main() {
    stack<int> s;
    cout << (s.empty() ? "栈为空" : "栈不为空") << endl;  // 输出: 栈为空
    s.push(100);
    cout << (s.empty() ? "栈为空" : "栈不为空") << endl;  // 输出: 栈不为空
    return 0;
}
```

------

##### **元素访问函数**

###### 3. `top()`：访问栈顶元素

```cpp
int main() {
    stack<int> s;
    s.push(10);
    s.push(20);
    cout << "栈顶元素: " << s.top() << endl;  // 输出: 20
    return 0;
}
```

------

##### **修改操作函数**

###### 4. `push(val)`：在栈顶插入元素

```cpp
int main() {
    stack<int> s;
    s.push(5);
    s.push(10);
    cout << "栈顶元素: " << s.top() << endl;  // 输出: 10
    return 0;
}
```

------

###### 5. `pop()`：移除栈顶元素

```cpp
int main() {
    stack<int> s;
    s.push(100);
    s.push(200);
    s.pop();
    cout << "当前栈顶元素: " << s.top() << endl;  // 输出: 100
    return 0;
}
```

------

###### 6. `swap(stack)`：与另一个栈交换内容

```cpp
int main() {
    stack<int> s1, s2;
    s1.push(1); s1.push(2);
    s2.push(3); s2.push(4);

    s1.swap(s2);
    cout << "s1 栈顶元素: " << s1.top() << endl;  // 输出: 4
    cout << "s2 栈顶元素: " << s2.top() << endl;  // 输出: 2
    return 0;
}
```

------

#### **4.4 更多使用示例**

##### **1. 使用 `stack` 反转字符串**

```cpp
#include <stack>
#include <string>
#include <iostream>
using namespace std;

int main() {
    string str = "hello";
    stack<char> s;
    for (char c : str) s.push(c);

    cout << "反转后的字符串: ";
    while (!s.empty()) {
        cout << s.top();  // 输出: olleh
        s.pop();
    }
    cout << endl;
    return 0;
}
```

------

##### **2. 检查括号匹配**

```cpp
#include <stack>
#include <string>
#include <iostream>
using namespace std;

bool isValid(string s) {
    stack<char> stk;
    for (char c : s) {
        if (c == '(' || c == '[' || c == '{') stk.push(c);
        else {
            if (stk.empty()) return false;
            char top = stk.top(); stk.pop();
            if ((c == ')' && top != '(') || 
                (c == ']' && top != '[') || 
                (c == '}' && top != '{')) return false;
        }
    }
    return stk.empty();
}

int main() {
    string expr = "{[()]}";
    cout << (isValid(expr) ? "括号匹配" : "括号不匹配") << endl;  // 输出: 括号匹配
    return 0;
}
```

------

##### **3. 使用 `stack` 实现十进制转二进制**

```cpp
#include <stack>
#include <iostream>
using namespace std;

void decToBin(int n) {
    stack<int> s;
    while (n > 0) {
        s.push(n % 2);
        n /= 2;
    }
    cout << "二进制表示: ";
    while (!s.empty()) {
        cout << s.top();  // 例如: 10 -> 1010
        s.pop();
    }
    cout << endl;
}

int main() {
    decToBin(10);  // 输出: 1010
    return 0;
}
```

------

##### **4. 使用 `stack` 实现深度优先搜索 (DFS)**

```cpp
#include <iostream>
#include <stack>
#include <vector>
using namespace std;

void DFS(vector<vector<int>> &graph, int start) {
    vector<bool> visited(graph.size(), false);
    stack<int> s;
    s.push(start);

    while (!s.empty()) {
        int node = s.top(); s.pop();
        if (!visited[node]) {
            cout << node << " ";  // 输出访问的节点
            visited[node] = true;
            for (auto it = graph[node].rbegin(); it != graph[node].rend(); ++it) {
                if (!visited[*it]) s.push(*it);
            }
        }
    }
    cout << endl;
}

int main() {
    vector<vector<int>> graph = {{1, 2}, {3}, {3}, {}};
    DFS(graph, 0);  // 输出: 0 2 3 1
    return 0;
}
```

------

#### **4.5 高级用法与技巧**

##### **1. 模拟递归调用栈**

使用 `stack` 模拟递归过程，便于分析递归逻辑。

```cpp
int factorial(int n) {
    stack<int> s;
    int result = 1;
    while (n > 1) {
        s.push(n--);
    }
    while (!s.empty()) {
        result *= s.top();
        s.pop();
    }
    return result;
}

int main() {
    cout << "5 的阶乘: " << factorial(5) << endl;  // 输出: 120
    return 0;
}
```

------

##### **2. 查找下一个更大元素**

```cpp
vector<int> nextGreaterElement(vector<int> &nums) {
    vector<int> res(nums.size(), -1);
    stack<int> s;
    for (int i = 0; i < nums.size(); i++) {
        while (!s.empty() && nums[i] > nums[s.top()]) {
            res[s.top()] = nums[i];
            s.pop();
        }
        s.push(i);
    }
    return res;
}

int main() {
    vector<int> nums = {2, 1, 2, 4, 3};
    auto res = nextGreaterElement(nums);
    for (int n : res) cout << n << " ";  // 输出: 4 2 4 -1 -1
    return 0;
}
```



### **5. 队列 `queue`（先进先出容器）**

#### **5.1 基本概念**

`std::queue` 是 C++ STL 中的一种容器适配器，遵循**先进先出 (FIFO, First In First Out)** 的数据结构。
 它通过封装其他序列容器（如 `deque` 或 `list`）实现，默认底层容器为 `deque`。

##### **主要特点：**

- **先进先出 (FIFO)**：最先插入的元素最先被移除。
- **只允许在队尾插入元素、在队首移除元素**。
- **不支持随机访问**。
- **底层容器默认使用 `deque`**，可以指定为 `list`。

##### **头文件：**

```cpp
#include <queue>
```

##### **命名空间：**

```cpp
using namespace std;
```

------

#### **5.2 常用操作**

##### **创建和初始化：**

```cpp
queue<int> q1;                      // 空队列
queue<int, deque<int>> q2;          // 使用 deque 作为底层容器
queue<int, list<int>> q3;           // 使用 list 作为底层容器
queue<int> q4(q1);                  // 拷贝构造
```

------

##### **遍历方式（通过出队访问）：**

```cpp
queue<int> q;
q.push(1);
q.push(2);
q.push(3);

// 通过出队遍历
while (!q.empty()) {
    cout << q.front() << " ";  // 输出: 1 2 3
    q.pop();
}
cout << endl;
```

------

#### **5.3 常用成员函数示例**

##### **容量相关函数**

###### 1. `size()`：返回队列中元素数量

```cpp
int main() {
    queue<int> q;
    q.push(10);
    q.push(20);
    cout << "元素数量: " << q.size() << endl;  // 输出: 2
    return 0;
}
```

------

###### 2. `empty()`：检查队列是否为空

```cpp
int main() {
    queue<int> q;
    cout << (q.empty() ? "队列为空" : "队列不为空") << endl;  // 输出: 队列为空
    q.push(100);
    cout << (q.empty() ? "队列为空" : "队列不为空") << endl;  // 输出: 队列不为空
    return 0;
}
```

------

##### **元素访问函数**

###### 3. `front()`：访问队首元素

```cpp
int main() {
    queue<int> q;
    q.push(10);
    q.push(20);
    cout << "队首元素: " << q.front() << endl;  // 输出: 10
    return 0;
}
```

------

###### 4. `back()`：访问队尾元素

```cpp
int main() {
    queue<int> q;
    q.push(10);
    q.push(20);
    cout << "队尾元素: " << q.back() << endl;  // 输出: 20
    return 0;
}
```

------

##### **修改操作函数**

###### 5. `push(val)`：在队尾插入元素

```cpp
int main() {
    queue<int> q;
    q.push(5);
    q.push(10);
    cout << "队尾元素: " << q.back() << endl;  // 输出: 10
    return 0;
}
```

------

###### 6. `pop()`：移除队首元素

```cpp
int main() {
    queue<int> q;
    q.push(100);
    q.push(200);
    q.pop();
    cout << "当前队首元素: " << q.front() << endl;  // 输出: 200
    return 0;
}
```

------

#### **5.4 更多使用示例**

##### **1. 使用 `queue` 实现广度优先搜索 (BFS)**

```cpp
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

void BFS(vector<vector<int>> &graph, int start) {
    vector<bool> visited(graph.size(), false);
    queue<int> q;
    q.push(start);
    visited[start] = true;

    while (!q.empty()) {
        int node = q.front();
        q.pop();
        cout << node << " ";  // 输出访问的节点
        for (auto &adj : graph[node]) {
            if (!visited[adj]) {
                visited[adj] = true;
                q.push(adj);
            }
        }
    }
    cout << endl;
}

int main() {
    vector<vector<int>> graph = {{1, 2}, {3}, {3}, {}};
    BFS(graph, 0);  // 输出: 0 1 2 3
    return 0;
}
```

------

##### **2. 模拟任务调度**

```cpp
#include <queue>
#include <iostream>
using namespace std;

int main() {
    queue<string> tasks;
    tasks.push("任务1");
    tasks.push("任务2");
    tasks.push("任务3");

    while (!tasks.empty()) {
        cout << "正在处理: " << tasks.front() << endl;  // 输出每个任务
        tasks.pop();
    }
    return 0;
}
```

------

##### **3. 银行排队模拟**

```cpp
#include <queue>
#include <iostream>
using namespace std;

int main() {
    queue<string> customers;
    customers.push("客户A");
    customers.push("客户B");
    customers.push("客户C");

    while (!customers.empty()) {
        cout << customers.front() << " 正在办理业务" << endl;
        customers.pop();
    }
    // 输出:
    // 客户A 正在办理业务
    // 客户B 正在办理业务
    // 客户C 正在办理业务
    return 0;
}
```

------

##### **4. 使用 `queue` 实现滑动窗口**

```cpp
#include <queue>
#include <iostream>
#include <vector>
using namespace std;

void slidingWindowMax(const vector<int> &nums, int k) {
    deque<int> dq;
    for (int i = 0; i < nums.size(); i++) {
        while (!dq.empty() && dq.front() <= i - k) dq.pop_front();
        while (!dq.empty() && nums[dq.back()] < nums[i]) dq.pop_back();
        dq.push_back(i);
        if (i >= k - 1) cout << nums[dq.front()] << " ";  // 窗口最大值
    }
    cout << endl;
}

int main() {
    vector<int> nums = {1, 3, -1, -3, 5, 3, 6, 7};
    int k = 3;
    slidingWindowMax(nums, k);  // 输出: 3 3 5 5 6 7
    return 0;
}
```

------

#### **5.5 高级用法与技巧**

##### **1. 使用 `queue` 模拟栈的行为**

```cpp
#include <queue>
#include <iostream>
using namespace std;

class MyStack {
private:
    queue<int> q;
public:
    void push(int x) {
        q.push(x);
        for (int i = 0; i < q.size() - 1; i++) {
            q.push(q.front());
            q.pop();
        }
    }
    void pop() { q.pop(); }
    int top() { return q.front(); }
    bool empty() { return q.empty(); }
};

int main() {
    MyStack s;
    s.push(1);
    s.push(2);
    cout << "栈顶元素: " << s.top() << endl;  // 输出: 2
    s.pop();
    cout << "栈顶元素: " << s.top() << endl;  // 输出: 1
    return 0;
}
```

------

##### **2. 使用 `queue` 判断是否为回文字符串**

```cpp
#include <queue>
#include <stack>
#include <iostream>
#include <string>
using namespace std;

bool isPalindrome(string s) {
    queue<char> q;
    stack<char> stk;
    for (char c : s) {
        q.push(c);
        stk.push(c);
    }
    while (!q.empty()) {
        if (q.front() != stk.top()) return false;
        q.pop();
        stk.pop();
    }
    return true;
}

int main() {
    string str = "abba";
    cout << (isPalindrome(str) ? "是回文" : "不是回文") << endl;  // 输出: 是回文
    return 0;
}
```

------

##### **3. 多级队列任务调度**

```cpp
#include <queue>
#include <iostream>
using namespace std;

int main() {
    queue<string> highPriority, lowPriority;
    highPriority.push("高优先级任务1");
    lowPriority.push("低优先级任务1");
    highPriority.push("高优先级任务2");
    lowPriority.push("低优先级任务2");

    while (!highPriority.empty() || !lowPriority.empty()) {
        if (!highPriority.empty()) {
            cout << highPriority.front() << endl;
            highPriority.pop();
        } else {
            cout << lowPriority.front() << endl;
            lowPriority.pop();
        }
    }
    // 输出:
    // 高优先级任务1
    // 高优先级任务2
    // 低优先级任务1
    // 低优先级任务2
    return 0;
}
```



### **6. 优先队列 `priority_queue`（堆实现的容器）**

#### **6.1 基本概念**

`std::priority_queue` 是 C++ STL 中的一种容器适配器，用于实现**优先级队列**，其底层通常基于**堆 (heap)** 实现。
 默认情况下，`priority_queue` 是**最大堆**（即队首元素为最大值），可以通过自定义比较器实现**最小堆**或其他排序规则。

##### **主要特点：**

- **最大堆（默认）：** 队首元素为当前队列中的最大值。
- **最小堆（自定义）：** 可以通过自定义比较器实现最小堆。
- **底层实现：** 使用 `vector` 和 `make_heap`、`push_heap`、`pop_heap` 实现。
- 常见操作的时间复杂度：
  - 插入元素 (`push`)：O(log n)
  - 删除最大元素 (`pop`)：O(log n)
  - 访问最大元素 (`top`)：O(1)

##### **头文件：**

```cpp
#include <queue>
```

##### **命名空间：**

```cpp
using namespace std;
```

------

#### **6.2 常用操作**

##### **创建和初始化：**

```cpp
priority_queue<int> pq1;                               // 默认最大堆
priority_queue<int, vector<int>, greater<int>> pq2;    // 最小堆
priority_queue<int> pq3(pq1);                          // 拷贝构造
```

------

##### **遍历方式（通过出队访问）：**

```cpp
priority_queue<int> pq;
pq.push(10);
pq.push(30);
pq.push(20);

while (!pq.empty()) {
    cout << pq.top() << " ";  // 输出: 30 20 10
    pq.pop();
}
cout << endl;
```

------

#### **6.3 常用成员函数示例**

##### **容量相关函数**

###### 1. `size()`：返回队列中元素数量

```cpp
int main() {
    priority_queue<int> pq;
    pq.push(10);
    pq.push(20);
    cout << "元素数量: " << pq.size() << endl;  // 输出: 2
    return 0;
}
```

------

###### 2. `empty()`：检查队列是否为空

```cpp
int main() {
    priority_queue<int> pq;
    cout << (pq.empty() ? "队列为空" : "队列不为空") << endl;  // 输出: 队列为空
    pq.push(100);
    cout << (pq.empty() ? "队列为空" : "队列不为空") << endl;  // 输出: 队列不为空
    return 0;
}
```

------

##### **元素访问函数**

###### 3. `top()`：访问队首元素（最大或最小值，取决于堆类型）

```cpp
int main() {
    priority_queue<int> pq;
    pq.push(10);
    pq.push(20);
    cout << "队首元素: " << pq.top() << endl;  // 输出: 20 (最大堆)
    return 0;
}
```

------

##### **修改操作函数**

###### 4. `push(val)`：在队列中插入元素

```cpp
int main() {
    priority_queue<int> pq;
    pq.push(5);
    pq.push(10);
    cout << "队首元素: " << pq.top() << endl;  // 输出: 10
    return 0;
}
```

------

###### 5. `pop()`：移除队首元素

```cpp
int main() {
    priority_queue<int> pq;
    pq.push(100);
    pq.push(200);
    pq.pop();
    cout << "当前队首元素: " << pq.top() << endl;  // 输出: 100
    return 0;
}
```

------

###### 6. `swap()`：与另一个优先队列交换内容

```cpp
int main() {
    priority_queue<int> pq1, pq2;
    pq1.push(1); pq1.push(2);
    pq2.push(3); pq2.push(4);

    pq1.swap(pq2);
    cout << "pq1 队首元素: " << pq1.top() << endl;  // 输出: 4
    cout << "pq2 队首元素: " << pq2.top() << endl;  // 输出: 2
    return 0;
}
```

------

#### **6.4 更多使用示例**

##### **1. 实现最小堆**

```cpp
priority_queue<int, vector<int>, greater<int>> minHeap;
minHeap.push(10);
minHeap.push(30);
minHeap.push(20);
while (!minHeap.empty()) {
    cout << minHeap.top() << " ";  // 输出: 10 20 30
    minHeap.pop();
}
cout << endl;
```

------

##### **2. 自定义数据类型的优先级**

```cpp
#include <queue>
#include <iostream>
using namespace std;

struct Task {
    int priority;
    string name;
    bool operator<(const Task &t) const {
        return priority < t.priority;  // 大优先级在前
    }
};

int main() {
    priority_queue<Task> tasks;
    tasks.push({2, "任务B"});
    tasks.push({1, "任务A"});
    tasks.push({3, "任务C"});

    while (!tasks.empty()) {
        cout << tasks.top().name << " 优先级: " << tasks.top().priority << endl;
        tasks.pop();
    }
    // 输出:
    // 任务C 优先级: 3
    // 任务B 优先级: 2
    // 任务A 优先级: 1
    return 0;
}
```

------

##### **3. 合并多个有序数组**

```cpp
#include <queue>
#include <vector>
#include <iostream>
using namespace std;

vector<int> mergeSortedArrays(vector<vector<int>> &lists) {
    using T = pair<int, pair<int, int>>;  // 值, (数组索引, 元素索引)
    priority_queue<T, vector<T>, greater<T>> pq;
    vector<int> result;

    for (int i = 0; i < lists.size(); i++) {
        if (!lists[i].empty()) pq.push({lists[i][0], {i, 0}});
    }

    while (!pq.empty()) {
        auto [val, idx] = pq.top(); pq.pop();
        result.push_back(val);
        if (++idx.second < lists[idx.first].size()) {
            pq.push({lists[idx.first][idx.second], idx});
        }
    }
    return result;
}

int main() {
    vector<vector<int>> lists = {{1, 4, 5}, {1, 3, 4}, {2, 6}};
    auto merged = mergeSortedArrays(lists);
    for (int val : merged) cout << val << " ";  // 输出: 1 1 2 3 4 4 5 6
    cout << endl;
    return 0;
}
```

------

##### **4. 寻找数组中前 K 大的元素**

```cpp
#include <queue>
#include <vector>
#include <iostream>
using namespace std;

vector<int> topKElements(vector<int> &nums, int k) {
    priority_queue<int, vector<int>, greater<int>> pq;
    for (auto &num : nums) {
        pq.push(num);
        if (pq.size() > k) pq.pop();
    }
    vector<int> res;
    while (!pq.empty()) {
        res.push_back(pq.top());
        pq.pop();
    }
    return res;
}

int main() {
    vector<int> nums = {5, 2, 9, 1, 7, 6};
    int k = 3;
    auto topK = topKElements(nums, k);
    for (auto val : topK) cout << val << " ";  // 输出: 6 7 9
    cout << endl;
    return 0;
}
```

------

#### **6.5 高级用法与技巧**

##### **1. 自定义排序规则（按字符串长度排序）**

```cpp
#include <queue>
#include <string>
#include <iostream>
using namespace std;

struct CompareLength {
    bool operator()(const string &a, const string &b) {
        return a.size() > b.size();  // 按字符串长度升序
    }
};

int main() {
    priority_queue<string, vector<string>, CompareLength> pq;
    pq.push("apple");
    pq.push("banana");
    pq.push("kiwi");

    while (!pq.empty()) {
        cout << pq.top() << " ";  // 输出: kiwi apple banana
        pq.pop();
    }
    cout << endl;
    return 0;
}
```

------

##### **2. 实现流数据中的中位数**

```cpp
#include <queue>
#include <iostream>
using namespace std;

class MedianFinder {
    priority_queue<int> maxHeap;  // 存储较小一半
    priority_queue<int, vector<int>, greater<int>> minHeap;  // 存储较大一半
public:
    void addNum(int num) {
        if (maxHeap.empty() || num <= maxHeap.top()) maxHeap.push(num);
        else minHeap.push(num);

        if (maxHeap.size() > minHeap.size() + 1) {
            minHeap.push(maxHeap.top()); maxHeap.pop();
        } else if (minHeap.size() > maxHeap.size()) {
            maxHeap.push(minHeap.top()); minHeap.pop();
        }
    }

    double findMedian() {
        if (maxHeap.size() == minHeap.size()) 
            return (maxHeap.top() + minHeap.top()) / 2.0;
        return maxHeap.top();
    }
};

int main() {
    MedianFinder mf;
    mf.addNum(1);
    mf.addNum(2);
    cout << "当前中位数: " << mf.findMedian() << endl;  // 输出: 1.5
    mf.addNum(3);
    cout << "当前中位数: " << mf.findMedian() << endl;  // 输出: 2
    return 0;
}
```

------

##### **3. 寻找 K 路合并排序数组的最小范围**

```cpp
#include <queue>
#include <vector>
#include <iostream>
#include <climits>
using namespace std;

struct Node {
    int val, row, col;
    bool operator>(const Node &other) const { return val > other.val; }
};

pair<int, int> smallestRange(vector<vector<int>> &nums) {
    priority_queue<Node, vector<Node>, greater<Node>> pq;
    int maxVal = INT_MIN, rangeStart = 0, rangeEnd = INT_MAX;

    for (int i = 0; i < nums.size(); i++) {
        pq.push({nums[i][0], i, 0});
        maxVal = max(maxVal, nums[i][0]);
    }

    while (pq.size() == nums.size()) {
        Node curr = pq.top(); pq.pop();
        if (maxVal - curr.val < rangeEnd - rangeStart) {
            rangeStart = curr.val;
            rangeEnd = maxVal;
        }
        if (++curr.col < nums[curr.row].size()) {
            curr.val = nums[curr.row][curr.col];
            pq.push(curr);
            maxVal = max(maxVal, curr.val);
        } else break;
    }
    return {rangeStart, rangeEnd};
}

int main() {
    vector<vector<int>> nums = {{4,10,15,24,26},{0,9,12,20},{5,18,22,30}};
    auto res = smallestRange(nums);
    cout << "最小范围: [" << res.first << ", " << res.second << "]" << endl;
    // 输出: [20, 24]
    return 0;
}
```



### **7. 成对容器 `pair`（存储两个相关数据的容器）**

#### **7.1 基本概念**

`std::pair` 是 C++ STL 中的一种简单容器，用于存储**两个相关联的值**，可以是不同类型。它常用于存储键值对、函数返回多个值以及与其他容器（如 `map` 和 `priority_queue`）搭配使用。

##### **主要特点：**

- 存储两个值，分别通过 `first` 和 `second` 成员访问。
- 两个值可以是不同的数据类型。
- 提供内置的比较运算符（如 `<`、`==`、`!=`、`>` 等），按 `first` 进行字典序排序，若 `first` 相等，则比较 `second`。
- 可以结合 `make_pair()` 函数快速创建。

##### **头文件：**

```cpp
#include <utility>
```

##### **命名空间：**

```cpp
using namespace std;
```

------

#### **7.2 常用操作**

##### **创建和初始化：**

```cpp
pair<int, string> p1;                      // 默认构造
pair<int, string> p2(1, "one");             // 通过构造函数初始化
pair<int, string> p3 = make_pair(2, "two"); // 使用 make_pair 创建
pair<int, string> p4 = p2;                  // 拷贝构造
```

------

##### **访问元素：**

```cpp
pair<int, string> p = make_pair(1, "one");
cout << "first: " << p.first << endl;   // 输出: first: 1
cout << "second: " << p.second << endl; // 输出: second: one
```

------

#### **7.3 常用成员函数示例**

##### **1. `make_pair()`：创建 pair 对象**

```cpp
int main() {
    pair<int, string> p = make_pair(10, "ten");
    cout << "first: " << p.first << ", second: " << p.second << endl;
    // 输出: first: 10, second: ten
    return 0;
}
```

------

##### **2. 赋值操作**

```cpp
int main() {
    pair<int, string> p1 = make_pair(1, "one");
    pair<int, string> p2;
    p2 = p1;
    cout << "p2: " << p2.first << ", " << p2.second << endl;
    // 输出: p2: 1, one
    return 0;
}
```

------

##### **3. 比较运算符**

```cpp
int main() {
    pair<int, int> p1 = {1, 10};
    pair<int, int> p2 = {1, 20};

    cout << (p1 < p2 ? "p1 < p2" : "p1 >= p2") << endl;  // 输出: p1 < p2
    cout << (p1 == p2 ? "p1 == p2" : "p1 != p2") << endl;  // 输出: p1 != p2
    return 0;
}
```

------

##### **4. 交换两个 `pair`**

```cpp
int main() {
    pair<int, string> p1 = {1, "one"};
    pair<int, string> p2 = {2, "two"};
    p1.swap(p2);
    cout << "p1: " << p1.first << ", " << p1.second << endl;  // 输出: p1: 2, two
    cout << "p2: " << p2.first << ", " << p2.second << endl;  // 输出: p2: 1, one
    return 0;
}
```

------

#### **7.4 更多使用示例**

##### **1. `pair` 作为 `map` 的键值对**

```cpp
#include <map>
#include <iostream>
using namespace std;

int main() {
    map<int, string> m;
    m.insert(make_pair(1, "one"));
    m.insert({2, "two"});

    for (auto &p : m) {
        cout << p.first << ": " << p.second << endl;
        // 输出:
        // 1: one
        // 2: two
    }
    return 0;
}
```

------

##### **2. 使用 `pair` 返回多个值**

```cpp
#include <utility>
#include <iostream>
using namespace std;

pair<int, int> getMinMax(int a, int b) {
    return {min(a, b), max(a, b)};
}

int main() {
    auto result = getMinMax(10, 5);
    cout << "最小值: " << result.first << ", 最大值: " << result.second << endl;
    // 输出: 最小值: 5, 最大值: 10
    return 0;
}
```

------

##### **3. `pair` 作为 `priority_queue` 的元素**

```cpp
#include <queue>
#include <iostream>
using namespace std;

int main() {
    priority_queue<pair<int, string>> pq;
    pq.push({3, "C"});
    pq.push({1, "A"});
    pq.push({2, "B"});

    while (!pq.empty()) {
        cout << pq.top().second << " 优先级: " << pq.top().first << endl;
        pq.pop();
    }
    // 输出:
    // C 优先级: 3
    // B 优先级: 2
    // A 优先级: 1
    return 0;
}
```

------

##### **4. `pair` 用于自定义排序**

```cpp
#include <vector>
#include <algorithm>
#include <iostream>
using namespace std;

int main() {
    vector<pair<string, int>> v = {{"Alice", 25}, {"Bob", 20}, {"Charlie", 30}};
    sort(v.begin(), v.end(), [](auto &a, auto &b) {
        return a.second < b.second;
    });

    for (auto &p : v) {
        cout << p.first << " - " << p.second << endl;
        // 输出:
        // Bob - 20
        // Alice - 25
        // Charlie - 30
    }
    return 0;
}
```

------

#### **7.5 高级用法与技巧**

##### **1. 嵌套 `pair` 表示多维数据**

```cpp
#include <utility>
#include <iostream>
using namespace std;

int main() {
    pair<int, pair<int, int>> point3D = {1, {2, 3}};
    cout << "x: " << point3D.first 
         << ", y: " << point3D.second.first 
         << ", z: " << point3D.second.second << endl;
    // 输出: x: 1, y: 2, z: 3
    return 0;
}
```

------

##### **2. 使用 `tie` 解包 `pair`**

```cpp
#include <tuple>
#include <iostream>
using namespace std;

pair<int, string> getData() {
    return {100, "Data"};
}

int main() {
    int number;
    string text;
    tie(number, text) = getData();
    cout << "数字: " << number << ", 文本: " << text << endl;
    // 输出: 数字: 100, 文本: Data
    return 0;
}
```

------

##### **3. 与结构体结合进行排序**

```cpp
#include <vector>
#include <algorithm>
#include <iostream>
using namespace std;

struct Person {
    string name;
    int age;
};

int main() {
    vector<pair<int, Person>> people = {{2, {"Alice", 30}}, {1, {"Bob", 25}}};
    sort(people.begin(), people.end());

    for (auto &p : people) {
        cout << p.second.name << " - " << p.second.age << endl;
        // 输出:
        // Bob - 25
        // Alice - 30
    }
    return 0;
}
```

------

##### **4. 使用 `pair` 实现二维坐标排序**

```cpp
#include <vector>
#include <algorithm>
#include <iostream>
using namespace std;

int main() {
    vector<pair<int, int>> points = {{1, 3}, {1, 2}, {2, 1}, {2, 3}};
    sort(points.begin(), points.end());  // 默认按 first 排序，若相同按 second

    for (auto &p : points) {
        cout << "(" << p.first << ", " << p.second << ")" << endl;
        // 输出:
        // (1, 2)
        // (1, 3)
        // (2, 1)
        // (2, 3)
    }
    return 0;
}
```



### **8. 无序集合 `unordered_set`（基于哈希表的容器）**

#### **8.1 基本概念**

`std::unordered_set` 是 C++ STL 中的一种关联容器，用于存储**唯一的元素**，且元素的顺序是**无序的**。
 它的底层实现为**哈希表 (Hash Table)**，因此插入、删除和查找的平均时间复杂度为 **O(1)**。

##### **主要特点：**

- **唯一性**：所有元素都是唯一的。
- **无序性**：元素的存储顺序与插入顺序无关，由哈希函数决定。
- **高效性**：插入、删除和查找操作的平均时间复杂度为 **O(1)**，最坏情况下为 **O(n)**。
- **底层实现**：基于哈希表，允许自定义哈希函数和相等比较器。

##### **头文件：**

```cpp
#include <unordered_set>
```

##### **命名空间：**

```cpp
using namespace std;
```

------

#### **8.2 常用操作**

##### **创建和初始化：**

```cpp
unordered_set<int> s1;                           // 空集合
unordered_set<int> s2 = {1, 2, 3, 4, 5};          // 列表初始化
unordered_set<int> s3(s2);                       // 拷贝构造
unordered_set<string> s4 = {"apple", "banana"};  // 存储字符串
```

------

##### **遍历方式：**

```cpp
unordered_set<int> s = {10, 20, 30, 40, 50};

// 范围 for 循环
for (auto &val : s) {
    cout << val << " ";  // 输出顺序无序
}
cout << endl;

// 迭代器遍历
for (unordered_set<int>::iterator it = s.begin(); it != s.end(); ++it) {
    cout << *it << " ";  // 输出顺序无序
}
cout << endl;
```

------

#### **8.3 常用成员函数示例**

##### **容量相关函数**

###### 1. `size()`：返回元素数量

```cpp
int main() {
    unordered_set<int> s = {1, 2, 3, 4};
    cout << "元素数量: " << s.size() << endl;  // 输出: 4
    return 0;
}
```

------

###### 2. `empty()`：检查集合是否为空

```cpp
int main() {
    unordered_set<int> s;
    cout << (s.empty() ? "集合为空" : "集合不为空") << endl;  // 输出: 集合为空
    s.insert(10);
    cout << (s.empty() ? "集合为空" : "集合不为空") << endl;  // 输出: 集合不为空
    return 0;
}
```

------

##### **元素访问函数**

###### 3. `find(val)`：查找元素，返回指向元素的迭代器

```cpp
int main() {
    unordered_set<int> s = {10, 20, 30};
    auto it = s.find(20);
    if (it != s.end()) cout << "找到元素: " << *it << endl;  // 输出: 找到元素: 20
    else cout << "未找到元素" << endl;
    return 0;
}
```

------

###### 4. `count(val)`：返回元素出现的次数（`unordered_set` 中为 0 或 1）

```cpp
int main() {
    unordered_set<int> s = {10, 20, 30};
    cout << "元素 20 出现次数: " << s.count(20) << endl;  // 输出: 1
    cout << "元素 40 出现次数: " << s.count(40) << endl;  // 输出: 0
    return 0;
}
```

------

##### **修改操作函数**

###### 5. `insert(val)`：插入元素（若元素已存在，则不插入）

```cpp
int main() {
    unordered_set<int> s = {10, 20};
    s.insert(30);
    s.insert(20);  // 已存在，不插入
    for (auto val : s) cout << val << " ";  // 输出顺序无序，如: 20 10 30
    return 0;
}
```

------

###### 6. `erase(val)`：删除指定元素

```cpp
int main() {
    unordered_set<int> s = {10, 20, 30};
    s.erase(20);
    for (auto val : s) cout << val << " ";  // 输出: 10 30（顺序无序）
    return 0;
}
```

------

###### 7. `clear()`：清空集合

```cpp
int main() {
    unordered_set<int> s = {100, 200, 300};
    s.clear();
    cout << "清除后元素数量: " << s.size() << endl;  // 输出: 0
    return 0;
}
```

------

###### 8. `swap()`：与另一个集合交换内容

```cpp
int main() {
    unordered_set<int> s1 = {1, 2, 3};
    unordered_set<int> s2 = {4, 5, 6};
    s1.swap(s2);
    for (auto val : s1) cout << val << " ";  // 输出: 4 5 6
    return 0;
}
```

------

#### **8.4 更多使用示例**

##### **1. `unordered_set` 实现唯一元素集合**

```cpp
#include <unordered_set>
#include <vector>
#include <iostream>
using namespace std;

int main() {
    vector<int> nums = {1, 2, 2, 3, 4, 4, 5};
    unordered_set<int> s(nums.begin(), nums.end());

    for (auto val : s) cout << val << " ";  // 输出唯一元素，顺序无序: 1 2 3 4 5
    cout << endl;
    return 0;
}
```

------

##### **2. 判断两个集合是否有交集**

```cpp
#include <unordered_set>
#include <iostream>
using namespace std;

int main() {
    unordered_set<int> s1 = {1, 2, 3, 4};
    unordered_set<int> s2 = {3, 4, 5, 6};

    bool hasIntersection = false;
    for (auto val : s1) {
        if (s2.count(val)) {
            hasIntersection = true;
            break;
        }
    }
    cout << (hasIntersection ? "有交集" : "无交集") << endl;  // 输出: 有交集
    return 0;
}
```

------

##### **3. 统计字符串中不同字符的数量**

```cpp
#include <unordered_set>
#include <string>
#include <iostream>
using namespace std;

int main() {
    string s = "programming";
    unordered_set<char> uniqueChars(s.begin(), s.end());
    cout << "不同字符数量: " << uniqueChars.size() << endl;  // 输出: 8
    return 0;
}
```

------

##### **4. 自定义哈希函数存储自定义数据类型**

```cpp
#include <unordered_set>
#include <iostream>
using namespace std;

struct Point {
    int x, y;
    bool operator==(const Point &p) const { return x == p.x && y == p.y; }
};

struct HashFunction {
    size_t operator()(const Point &p) const {
        return hash<int>()(p.x) ^ (hash<int>()(p.y) << 1);
    }
};

int main() {
    unordered_set<Point, HashFunction> points;
    points.insert({1, 2});
    points.insert({3, 4});
    points.insert({1, 2});  // 重复元素不会插入

    cout << "点的数量: " << points.size() << endl;  // 输出: 2
    return 0;
}
```

------

#### **8.5 高级用法与技巧**

##### **1. `unordered_set` 查找子数组中是否存在和为目标值的子集**

```cpp
#include <unordered_set>
#include <vector>
#include <iostream>
using namespace std;

bool hasSubarrayWithSum(const vector<int> &nums, int target) {
    unordered_set<int> prefixSums;
    int currentSum = 0;
    prefixSums.insert(0);

    for (auto num : nums) {
        currentSum += num;
        if (prefixSums.count(currentSum - target)) return true;
        prefixSums.insert(currentSum);
    }
    return false;
}

int main() {
    vector<int> nums = {1, 2, 3, 7, 5};
    int target = 12;
    cout << (hasSubarrayWithSum(nums, target) ? "存在子数组" : "不存在子数组") << endl;  // 输出: 存在子数组
    return 0;
}
```

------

##### **2. `unordered_set` 判断两个字符串是否为字母异位词**

```cpp
#include <unordered_set>
#include <string>
#include <iostream>
using namespace std;

bool isAnagram(const string &s, const string &t) {
    if (s.size() != t.size()) return false;
    unordered_multiset<char> set1(s.begin(), s.end());
    unordered_multiset<char> set2(t.begin(), t.end());
    return set1 == set2;
}

int main() {
    cout << (isAnagram("listen", "silent") ? "是字母异位词" : "不是字母异位词") << endl;  // 输出: 是字母异位词
    return 0;
}
```

------

##### **3. 使用 `unordered_set` 快速去重**

```cpp
#include <unordered_set>
#include <vector>
#include <iostream>
using namespace std;

int main() {
    vector<int> nums = {4, 5, 6, 4, 5, 7};
    unordered_set<int> uniqueNums(nums.begin(), nums.end());

    for (auto val : uniqueNums) cout << val << " ";  // 输出唯一元素，顺序无序: 4 5 6 7
    cout << endl;
    return 0;
}
```



### **9. 字符串 `string`（字符串处理容器）**

#### **9.1 基本概念**

`std::string` 是 C++ STL 提供的字符串类，用于表示和操作字符串。
 它封装了动态分配的字符数组，提供了丰富的字符串操作函数，如拼接、查找、比较、提取子串等。

##### **主要特点：**

- 自动管理内存。
- 提供类似 C 风格字符串 (`char*`) 的接口，并且更安全易用。
- 支持字符串拼接、查找、替换、插入、删除等操作。
- 动态大小调整，支持随机访问。

##### **头文件：**

```cpp
#include <string>
```

##### **命名空间：**

```cpp
using namespace std;
```

------

#### **9.2 常用操作**

##### **创建和初始化：**

```cpp
string s1;                     // 空字符串
string s2 = "Hello";           // 字面量初始化
string s3("World");            // 构造函数初始化
string s4(5, 'a');             // 重复字符初始化: "aaaaa"
string s5 = s2 + " " + s3;     // 拼接: "Hello World"
```

------

##### **遍历方式：**

```cpp
string s = "Hello";

// 传统 for 循环
for (int i = 0; i < s.size(); i++) cout << s[i] << " ";  // 输出: H e l l o

// 范围 for 循环
for (auto c : s) cout << c << " ";  // 输出: H e l l o

// 迭代器遍历
for (auto it = s.begin(); it != s.end(); ++it) cout << *it << " ";  // 输出: H e l l o
```

------

#### **9.3 常用成员函数示例**

##### **容量相关函数**

###### 1. `size()` / `length()`：返回字符串长度

```cpp
int main() {
    string s = "Hello";
    cout << "长度: " << s.size() << endl;    // 输出: 5
    cout << "长度: " << s.length() << endl;  // 输出: 5
    return 0;
}
```

------

###### 2. `empty()`：检查字符串是否为空

```cpp
int main() {
    string s;
    cout << (s.empty() ? "字符串为空" : "字符串不为空") << endl;  // 输出: 字符串为空
    s = "Hello";
    cout << (s.empty() ? "字符串为空" : "字符串不为空") << endl;  // 输出: 字符串不为空
    return 0;
}
```

------

##### **元素访问函数**

###### 3. `at(index)`：访问指定索引的字符（带边界检查）

```cpp
int main() {
    string s = "Hello";
    cout << "索引 1 的字符: " << s.at(1) << endl;  // 输出: e
    return 0;
}
```

------

###### 4. `front()` 和 `back()`：访问首字符和尾字符

```cpp
int main() {
    string s = "Hello";
    cout << "首字符: " << s.front() << endl;  // 输出: H
    cout << "尾字符: " << s.back() << endl;   // 输出: o
    return 0;
}
```

------

##### **修改操作函数**

###### 5. `append(str)`：追加字符串

```cpp
int main() {
    string s = "Hello";
    s.append(" World");
    cout << "拼接后: " << s << endl;  // 输出: Hello World
    return 0;
}
```

------

###### 6. `push_back(char)`：在末尾添加单个字符

```cpp
int main() {
    string s = "Hello";
    s.push_back('!');
    cout << "添加字符后: " << s << endl;  // 输出: Hello!
    return 0;
}
```

------

###### 7. `pop_back()`：移除末尾字符

```cpp
int main() {
    string s = "Hello!";
    s.pop_back();
    cout << "移除后: " << s << endl;  // 输出: Hello
    return 0;
}
```

------

###### 8. `insert(pos, str)`：在指定位置插入字符串

```cpp
int main() {
    string s = "Hello";
    s.insert(5, " World");
    cout << "插入后: " << s << endl;  // 输出: Hello World
    return 0;
}
```

------

###### 9. `erase(pos, len)`：从指定位置删除子串

```cpp
int main() {
    string s = "Hello World";
    s.erase(5, 6);  // 删除 " World"
    cout << "删除后: " << s << endl;  // 输出: Hello
    return 0;
}
```

------

###### 10. `replace(pos, len, str)`：用新字符串替换子串

```cpp
int main() {
    string s = "Hello World";
    s.replace(6, 5, "C++");
    cout << "替换后: " << s << endl;  // 输出: Hello C++
    return 0;
}
```

------

##### **字符串查找函数**

###### 11. `find(str)`：查找子串首次出现的位置

```cpp
int main() {
    string s = "Hello World";
    size_t pos = s.find("World");
    if (pos != string::npos) cout << "找到位置: " << pos << endl;  // 输出: 6
    else cout << "未找到" << endl;
    return 0;
}
```

------

###### 12. `rfind(str)`：查找子串最后一次出现的位置

```cpp
int main() {
    string s = "Hello World Hello";
    size_t pos = s.rfind("Hello");
    cout << "最后一次出现位置: " << pos << endl;  // 输出: 12
    return 0;
}
```

------

##### **字符串比较函数**

###### 13. `compare(str)`：比较两个字符串

```cpp
int main() {
    string s1 = "abc";
    string s2 = "abd";
    if (s1.compare(s2) < 0) cout << s1 << " 小于 " << s2 << endl;  // 输出: abc 小于 abd
    return 0;
}
```

------

##### **其他常用函数**

###### 14. `substr(pos, len)`：提取子串

```cpp
int main() {
    string s = "Hello World";
    cout << "子串: " << s.substr(6, 5) << endl;  // 输出: World
    return 0;
}
```

------

###### 15. `c_str()`：返回 C 风格字符串指针

```cpp
int main() {
    string s = "Hello";
    printf("%s\n", s.c_str());  // 输出: Hello
    return 0;
}
```

------

#### **9.4 更多使用示例**

##### **1. 反转字符串**

```cpp
#include <algorithm>
#include <string>
#include <iostream>
using namespace std;

int main() {
    string s = "Hello";
    reverse(s.begin(), s.end());
    cout << "反转后: " << s << endl;  // 输出: olleH
    return 0;
}
```

------

##### **2. 检查是否为回文字符串**

```cpp
#include <algorithm>
#include <string>
#include <iostream>
using namespace std;

bool isPalindrome(const string &s) {
    return equal(s.begin(), s.begin() + s.size() / 2, s.rbegin());
}

int main() {
    string s = "abba";
    cout << (isPalindrome(s) ? "是回文" : "不是回文") << endl;  // 输出: 是回文
    return 0;
}
```

------

##### **3. 分割字符串**

```cpp
#include <vector>
#include <sstream>
#include <string>
#include <iostream>
using namespace std;

vector<string> split(const string &s, char delimiter) {
    vector<string> tokens;
    string token;
    istringstream tokenStream(s);
    while (getline(tokenStream, token, delimiter)) tokens.push_back(token);
    return tokens;
}

int main() {
    string s = "apple,banana,orange";
    auto tokens = split(s, ',');
    for (auto &t : tokens) cout << t << endl;
    // 输出:
    // apple
    // banana
    // orange
    return 0;
}
```

------

##### **4. 将整数转换为字符串**

```cpp
#include <string>
#include <iostream>
using namespace std;

int main() {
    int num = 123;
    string s = to_string(num);
    cout << "字符串: " << s << endl;  // 输出: 123
    return 0;
}
```

------

##### **5. 将字符串转换为整数**

```cpp
#include <string>
#include <iostream>
using namespace std;

int main() {
    string s = "456";
    int num = stoi(s);
    cout << "整数: " << num << endl;  // 输出: 456
    return 0;
}
```

------

#### **9.5 高级用法与技巧**

##### **1. 自定义排序字符串数组**

```cpp
#include <vector>
#include <algorithm>
#include <string>
#include <iostream>
using namespace std;

int main() {
    vector<string> words = {"apple", "banana", "kiwi", "grape"};
    sort(words.begin(), words.end(), [](const string &a, const string &b) {
        return a.size() < b.size();
    });

    for (auto &w : words) cout << w << " ";  // 输出: kiwi apple grape banana
    cout << endl;
    return 0;
}
```

------

##### **2. 查找字符串中所有子串位置**

```cpp
#include <string>
#include <iostream>
using namespace std;

int main() {
    string s = "the quick brown fox jumps over the lazy dog";
    string target = "the";
    size_t pos = s.find(target);

    while (pos != string::npos) {
        cout << "找到位置: " << pos << endl;
        pos = s.find(target, pos + 1);
    }
    // 输出:
    // 找到位置: 0
    // 找到位置: 31
    return 0;
}
```

------

##### **3. 判断字符串是否只包含数字**

```cpp
#include <string>
#include <cctype>
#include <iostream>
using namespace std;

bool isNumeric(const string &s) {
    return all_of(s.begin(), s.end(), ::isdigit);
}

int main() {
    string s = "12345";
    cout << (isNumeric(s) ? "是数字" : "不是数字") << endl;  // 输出: 是数字
    return 0;
}
```

------

##### **4. 字符串大小写转换**

```cpp
#include <algorithm>
#include <string>
#include <iostream>
using namespace std;

int main() {
    string s = "HeLLo WoRLd";
    transform(s.begin(), s.end(), s.begin(), ::tolower);
    cout << "小写: " << s << endl;  // 输出: hello world

    transform(s.begin(), s.end(), s.begin(), ::toupper);
    cout << "大写: " << s << endl;  // 输出: HELLO WORLD
    return 0;
}
```
{% endraw %}