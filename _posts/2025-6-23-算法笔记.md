---
layout: post
title: 算法笔记
author: zzy
categories: [Algorithms, Programming, Summary]
tags: [C++, Sort, Tree, Backtrack, Dynamic Programming, Greedy Algorithms]
---

# 算法笔记

## 一、排序与查找

### 1.插入排序

#### *算法思想：*

每次将一个待排序的记录按其关键字大小插入到前面已排好的子序列中，直到全部记录插入完成。

#### *例题：*

| 索引 |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 数值 |  49  |  38  |  65  |  97  |  76  |  13  |  27  |  49  |

#### *思路：*

从第二个元素开始，依次处理每一个元素，并且处理的元素之前的元素均是已经排好的（加粗表示已处理好）。

（1）处理索引值为1的元素：由于38 < 49，故49向后移位，38插入到相应位置。

| 索引 |   0    |   1    |  2   |  3   |  4   |  5   |  6   |  7   |
| :--: | :----: | :----: | :--: | :--: | :--: | :--: | :--: | :--: |
| 数值 | **38** | **49** |  65  |  97  |  76  |  13  |  27  |  49  |

（2）处理索引值为2的元素：由于65 > 49，故不需要移动位置。

| 索引 |   0    |   1    |   2    |  3   |  4   |  5   |  6   |  7   |
| :--: | :----: | :----: | :----: | :--: | :--: | :--: | :--: | :--: |
| 数值 | **38** | **49** | **65** |  97  |  76  |  13  |  27  |  49  |

（3）（4）的步骤省略。

（5）处理索引值为5的元素：由于13 < 97，故97向后移位；又由于13 < 76，故76也向后移位......**（只要当前元素比它的前驱元素小，那么就让它的前驱元素向后移位，然后当前元素继续与再之前的一个元素比较，直到所有比当前元素大的元素都向后移位，此时就将当前元素插入到移动后产生的空位置）**。

| 索引 |   0    |   1    |   2    |   3    |   4    |   5    |  6   |  7   |
| :--: | :----: | :----: | :----: | :----: | :----: | :----: | :--: | :--: |
| 数值 | **13** | **38** | **49** | **65** | **76** | **97** |  27  |  49  |

处理完成后得到的最终结果为：

| 索引 |   0    |   1    |   2    |   3    |   4    |   5    |   6    |   7    |
| :--: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: |
| 数值 | **13** | **27** | **38** | **49** | **49** | **65** | **76** | **97** |

#### *算法实现：*

```c++
void InsertSort(int A[], int n)
{
    int i,j,temp;
    for (i = 1; i < n; i++)
    {
        if (A[i] < A[i-1]) // A[i]关键字小于前驱
        {
            temp = A[i]; // 用temp暂存A[i]
            for (j = i-1; j >= 0 && A[j] >temp; --j) // 检查所有前面已排好序的元素
                A[j+1] = A[j]; // 所有大于temp的元素均后移
            A[j+1] = temp; // 插入到相应位置
        }
    }
}
```

#### *算法实现（带哨兵）：*

```c++
void InsertSort(int A[], int n)
{
    int i, j;
    for (i = 2; i <= n; i++)
    {
        if (A[i] < A[i-1]) // A[i]关键字小于前驱
        {
            A[0] = A[i]; // 复制为哨兵，A[0]不存放元素
            for (j = i-1; A[0] < A[j]; --j) // 从后往前查找待插入位置
                A[j+1] = A[j]; // 向后移位
            A[j+1] = A[0]; // 复制到插入位置
        }
    }
}
```

优点：不用每轮循环都判断 j >= 0。

**更推荐使用带哨兵的方式。**

#### *算法效率分析：*

空间复杂度： O(1)

时间复杂度：主要来自对比关键字，移动元素。若有 n 个元素，则需要 n-1 趟处理。

​	最好情况：共 n-1 趟处理，每一趟只需要对比关键字一次，不用移动元素。（已经排序好）—— O(n)

​	最坏情况：共 n-1 趟处理，第 i 趟需要对比关键字 i+1 次，移动元素 i+2次。（原本为逆序）—— O(n^2^)

​	**平均时间复杂度：O(n^2^)**

**算法稳定性：稳定。**

#### *优化——折半插入排序：*

思路：先用折半查找找到应该插入的位置，再移动元素。

```c++
void InsertSort(int A[], int n)
{
    int i, j, low, high, mid;
    for (i = 2; i <= n; i++)
    {
        A[0] = A[i]; // 将A[i]暂存到A[0]
        low = 1; // 设置折半查找的范围
        high = i-1;
        while (low <= high)
        {
            mid = (low + high) // 取中间点
            if (A[mid] > A[0]) // 查找左半子表
                high = mid - 1;
            else // 查找右半子表
                low = mid + 1;
        }
        for (j = i-1; j >= high+1; --j)
            A[j+1] = A[j]; // 后移元素
        A[high+1] = A[0]; // 插入操作
    }
}
```

注意：一直到 low > high 时才停止折半查找。当 mid 所指元素等于当前元素时，应继续指令 low = mid + 1，以保证 “ 稳定性 ” 。最终应将当前元素插入到 low 所指位置，即 high + 1。

比起直接插入排序，该算法的比较关键字的次数变少了，但是移动元素的次数没变，整体来看**时间复杂度依然是O(n) 。**



### 2. 希尔排序

#### *算法思想：*

先将待排序表分割成若干形如 L [ i , i + d , i + 2d , … , i + kd ]的 “ 特殊 ” 子表，对各个子表分别进行直接插入排序。缩小增量 d。重复上述过程，直到 d = 1 为止。

#### *例题：*（索引 0 处作为暂存单元）

| 索引 |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 数值 |      |  49  |  38  |  65  |  97  |  76  |  13  |  27  |  49  |

#### *思路：*

（1）第一趟：d~1~ = n/2 = 4。

| 索引  |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 数值  |      |  49  |  38  |  65  |  97  |  76  |  13  |  27  |  49  |
| 子表1 |      |  49  |      |      |      |  76  |      |      |      |
| 子表2 |      |      |  38  |      |      |      |  13  |      |      |
| 子表3 |      |      |      |  65  |      |      |      |  27  |      |
| 子表4 |      |      |      |      |  97  |      |      |      |  49  |

对各个子表进行直接插入排序：

| 索引  |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 数值  |      |  49  |  13  |  27  |  49  |  76  |  38  |  65  |  97  |
| 子表1 |      |  49  |      |      |      |  76  |      |      |      |
| 子表2 |      |      |  13  |      |      |      |  38  |      |      |
| 子表3 |      |      |      |  27  |      |      |      |  65  |      |
| 子表4 |      |      |      |      |  49  |      |      |      |  97  |

（2）第二趟：d~2~ = d~1~/2 = 2。

| 索引  |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 数值  |      |  49  |  13  |  27  |  49  |  76  |  38  |  65  |  97  |
| 子表1 |      |  49  |      |  27  |      |  76  |      |  65  |      |
| 子表2 |      |      |  13  |      |  49  |      |  38  |      |  97  |

对各个子表进行直接插入排序：

| 索引  |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 数值  |      |  27  |  13  |  49  |  38  |  65  |  49  |  76  |  97  |
| 子表1 |      |  27  |      |  49  |      |  65  |      |  76  |      |
| 子表2 |      |      |  13  |      |  38  |      |  49  |      |  97  |

（2）第三趟：d~3~ = d~2~/2 = 1。

| 索引  |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 数值  |      |  27  |  13  |  49  |  38  |  65  |  49  |  76  |  97  |
| 子表1 |      |  27  |  13  |  49  |  38  |  65  |  49  |  76  |  97  |

对各个子表进行直接插入排序：

| 索引  |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 数值  |      |  13  |  27  |  38  |  49  |  49  |  65  |  76  |  97  |
| 子表1 |      |  13  |  27  |  38  |  49  |  49  |  65  |  76  |  97  |

建议：每次将增量缩小一半。

#### *算法实现：*

```c++
void ShellSort(int A[], int n)
{
    int d, i, j;
    // A[0]只是暂存单元，不是哨兵，当j<=0时，插入为止已到
    for (d = n/2; d >= 1; d = d/2) // 步长变化
    {
        if (A[i] < A[i-d]) // 需要将A[i]插入有序增量子表
        {
            A[0] = A[i]; // 暂存在A[0]
            for (j = i-d; j > 0 && A[0] < A[j]; j -= d)
                A[j+d] = A[j]; // 记录后移，查找插入的位置
            A[j+d] = A[0]; // 插入
        }
    }
}
```

#### *算法效率分析：*

空间复杂度：O(1)

时间复杂度：和增量 d~1~，d~2~，d~3~ … 的选择有关，**目前无法用数学手段证明确切的时间复杂度**。最坏时间复杂度为 O(n^2^) ，当 n 在某个范围内时，可达 O(n^1.3^) 。

算法稳定性：不稳定。

适用性：仅用于顺序表，不适用于链表。



### 3. 冒泡排序

#### *算法思想：*

从后往前（或从前往后）两两比较相邻元素的值，若为逆序（即 A[ i - 1 ] > A[ i ]），则交换它们，直到序列比较完。称这样过程为    “ 一趟 ” 冒泡排序。

#### *例题：*

| 索引 |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 数值 |  49  |  38  |  65  |  97  |  76  |  13  |  27  |  49  |

#### *思路：*

（1）第一趟：第一趟排序使关键字值最小的一个元素 “ 冒 ” 到最前面。

| 索引 |   0    |  1   |  2   |  3   |  4   |  5   |  6   |  7   |
| :--: | :----: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 数值 | **13** |  49  |  38  |  65  |  97  |  76  |  27  |  49  |

（2）第二趟：第二趟排序使关键字值第二小的一个元素 “ 冒 ” 到第二个位置。

| 索引 |   0    |   1    |  2   |  3   |  4   |  5   |  6   |  7   |
| :--: | :----: | :----: | :--: | :--: | :--: | :--: | :--: | :--: |
| 数值 | **13** | **27** |  49  |  38  |  65  |  97  |  76  |  49  |

注意：由于第一趟排序完成之后，第一个元素已经确定了最终位置，因此第二趟排序过程中不需要再和这个元素进行比较。

后续步骤同上，省略。

若某一趟排序没有发生 “ 交换 ” ，说明此时已经整体有序。

处理完成后得到的最终结果为：

| 索引 |   0    |   1    |   2    |   3    |   4    |   5    |   6    |   7    |
| :--: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: |
| 数值 | **13** | **27** | **38** | **49** | **49** | **65** | **76** | **97** |

#### *算法实现：*

```c++
void BubbleSort(int A[], int n)
{
    for (int i = 0; i < n-1; i++)
    {
        bool flag = false; // 标志，用于记录本趟冒泡排序是否发生交换
        for (int j = n-1; j > i; j--)
        {
            if (A[j-1] > A[j]) // 是否为逆序
            {
                int temp = A[j-1]; // 进行交换
                A[j] = A[j-1];
                A[j-1] = temp;
                flag = true;
            }
        }
        if (flag == false)
        	return; // 本轮遍历后没有发生交换，说明表已经有序
    }
}
```

#### *算法效率分析：*

空间复杂度：O(1)

时间复杂度：最好情况（有序），比较次数为 n-1 次，交换次数为 0 次，此时的时间复杂度为 O(n) 。

​		       最坏情况（逆序），比较次数和交换次数均为 n (n-1) / 2 次，此时的时间复杂度为 O(n^2^) 。

​                       **平均时间复杂度为 O(n^2^) 。**

**算法稳定性：稳定。**

冒泡排序也可以用于链表。



### 4. 快速排序（*）

#### *算法思想：*

在待排序表 L [ 1 … n ] 中任取一个元素 pivot 作为枢轴（或基准，通常取首元素），通过一趟排序将待排序表划分为独立的两部分 L [ 1 … k-1 ] 和 L [ k+1 … n ] ，使得 L [ 1 … k-1 ] 中的所有元素小于pivot， L [ k+1 … n ] 中的所有元素大于等于 pivot ，则 pivot 放在了其最终位置 L(k) 上，这个过程称为一次 “ 划分 ” 。然后分别递归地对两个子表重复上述过程，直到每部分内只有一个元素为或为空为止，即所有元素放在了其最终位置上。

#### *例题：*

| 索引 |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 数值 |  49  |  38  |  65  |  97  |  76  |  13  |  27  |  49  |
| 指针 | low  |      |      |      |      |      |      | high |

#### *思路：*

（1）选择 low 指向的元素作为基准元素，比它更小的元素都交换到左边，更大的元素都交换到右边。由于此时 low 指向的位置是空的，故我们先从high指针所指处开始判断，因为 49 >= 49，因此不需要交换，high 指针左移。

| 索引 | 基准元素 |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |
| :--: | :------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 数值 |    49    |      |  38  |  65  |  97  |  76  |  13  |  27  |  49  |
| 指针 |          | low  |      |      |      |      |      | high |      |

（2）此时 high 所指的元素 27 < 49 ，故我们将 27 移动到 low 指针所指处。由于 high 指向的位置是空的，我们让 low 指针向右移。

| 索引 | 基准元素 |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |
| :--: | :------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 数值 |    49    |  27  |  38  |  65  |  97  |  76  |  13  |      |  49  |
| 指针 |          |      | low  |      |      |      |      | high |      |

（3）此时 low 所指元素 38 < 49，故我们将 low 指针继续右移。下一个指向的元素 65 > 49，故我们将 65 移动到 high 指针所指处。然后又让 high 指针左移。

| 索引 | 基准元素 |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |
| :--: | :------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 数值 |    49    |  27  |  38  |      |  97  |  76  |  13  |  65  |  49  |
| 指针 |          |      |      | low  |      |      | high |      |      |

后续步骤同上，省略。

（4）最终到 low 指针与 high 指针重合时，我们就完成了一个划分。得到的结果为：

| 索引 | 基准元素 |  0   |  1   |  2   |         3          |  4   |  5   |  6   |  7   |
| :--: | :------: | :--: | :--: | :--: | :----------------: | :--: | :--: | :--: | :--: |
| 数值 |    49    |  27  |  38  |  13  | **49（基准元素）** |  76  |  97  |  65  |  49  |
| 指针 |          |      |      |      |     low / high     |      |      |      |      |

接下来将上表划分为左、右两个子表，重复之前的步骤，对这两个子表继续进行划分，直到每部分内只有一个元素为或为空，此时就完成了排序。得到的最终结果为：

| 索引 |   0    |   1    |   2    |   3    |   4    |   5    |   6    |   7    |
| :--: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: |
| 数值 | **13** | **27** | **38** | **49** | **49** | **65** | **76** | **97** |

#### *算法实现：*

```c++
// 用第一个元素将待排序序列划分为左右两个部分
int Partition(int A[], int low, int high)
{
    int pivot = A[low]; // 第一个元素作为枢轴
    while (low < high) // 使用low，high搜索枢轴的最终位置
    {
        while (low < high && A[high] >= pivot)
            high--;
        A[low] = A[high]; // 比枢轴小的元素移动到左端
        while (low < high && A[low] <= pivot)
            low++;
        A[high] = A[low]; // 比枢轴大的元素移动到右端
    }
    A[low] = pivot; // 枢轴元素存放到最终位置
    return low;  // 返回枢轴存放的最终位置
}
// 快速排序
void QuickSort(int A[], int low, int high)
{
    if (low < high)
    {
        int pivotpos = Partition(A, low, high); // 划分
        QuickSort(A, low, pivotpos-1); // 划分左子表
        QuickSort(A, pivotpos+1, high); // 划分右子表
    }
}
```

#### *算法效率分析：*

空间复杂度：O(递归层数)

时间复杂度：每一层的 QuickSort 只需要处理剩余的待排序元素，时间复杂度不超过 O(n)。总的时间复杂度为：O(n * 递归层数)。

把 n 个元素组织成二叉树，二叉树的层数就是递归调用的层数。对于 n 个元素的二叉树而言，它的最小高度为 $\left \lfloor   log_2n\right \rfloor + 1$，最大高度为 n。

因此，最好时间复杂度为：O(nlog~2~n)，最坏时间复杂度为：O(n^2^)。**平均时间复杂度为：O(nlog~2~n)**。

​	    最好空间复杂度为：O(log~2~n)，最坏空间复杂度为：O(n)。

稳定性：**不稳定**。

#### *快速排序优化思路：*

若每一次选中的 “ 枢轴 ” 将待排序序列划分为**很不均匀**的两个部分，则会导致递归深度增加，算法效率变低。

若初始序列**有序或者逆序**，则快速排序的性能最差，因为每次选择的都是最靠边的元素。

因此，尽量选择可以**把数据中分的枢轴元素**。



### 5. 简单选择排序

#### *算法思想：*

每一趟在待排序元素中选取关键字最小的元素加入有序子序列。

#### *例题：*

| 索引 |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 数值 |  49  |  38  |  65  |  97  |  76  |  13  |  27  |  49  |

#### *思路：*

（1）遍历所有元素，找出关键字最小的元素，这里最小的是13，然后将13与49交换位置。

| 索引 |   0    |  1   |  2   |  3   |  4   |  5   |  6   |  7   |
| :--: | :----: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 数值 | **13** |  38  |  65  |  97  |  76  |  49  |  27  |  49  |

（2）继续遍历剩下的元素，找出最小的元素，并与除13之外最左边的元素交换位置。

| 索引 |   0    |   1    |  2   |  3   |  4   |  5   |  6   |  7   |
| :--: | :----: | :----: | :--: | :--: | :--: | :--: | :--: | :--: |
| 数值 | **13** | **27** |  65  |  97  |  76  |  49  |  38  |  49  |

后续步骤同上，省略。

最后只剩下最后一个元素的时候就不需要继续处理了。最终结果为：

| 索引 |   0    |   1    |   2    |   3    |   4    |   5    |   6    |   7    |
| :--: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: |
| 数值 | **13** | **27** | **38** | **49** | **49** | **65** | **76** | **97** |

n 个元素的简单选择排序需要 n-1 趟处理。

#### *算法实现：*

```c++
void SelectSort(int A[], int n)
{
    for (int i = 0; i < n-1; i++) // 一共进行n-1趟
    {
        int min = i; // 记录最小元素位置
        for (int j = i+1; j < n; j++)
        {
            if (A[j] < A[min])
                min = j; // 更新最小元素位置
            if (min != i)
            {
                int temp = A[i];
                A[i] = A[min];
                A[min] = temp;
            }
        }
    }
}
```

#### *算法效率分析：*

空间复杂度：O(1)

时间复杂度：无论有序、逆序、还是乱序，一定需要 n-1 趟处理。总共需要对比关键字 $(n-1) + (n-2) + … + 1 = \dfrac{n(n-1)}{2} $次。元素交换次数 < n-1。故时间复杂度为O(n^2^)。

稳定性：不稳定。

适用性：既可以用于顺序表，也可以用于链表。



### 6. 堆排序（*）

#### *堆的定义：*

若 n 个关键字序列 L [ 1 … n ] 满足下面某一条性质，则称为堆（heap）。

1. 若满足：L ( i ) >= L ( 2i ) 且 L ( i ) >= L ( 2i+1 ) （ 1 <= i <= n/2 ）—— 大根堆（大顶堆）。

2. 若满足：L ( i ) <= L ( 2i ) 且 L ( i ) <= L ( 2i+1 ) （ 1 <= i <= n/2 ）—— 小根堆（小顶堆）。

#### *算法思想：（以大根堆为例）*

把所有非终端节点都检查一遍，是否满足大根堆的要求，如果不满足，则进行调整。检查当前节点是否满足：根 >= 左、右，若不满足，则将当前节点与更大的一个孩子互换。若元素互换破坏了下一级的堆，则采用相同的方法继续往下调整。（小元素不断 “ 下坠 ” ）

#### *例题：*

| 索引 |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 数值 |      |  53  |  17  |  78  |  09  |  45  |  65  |  87  |  32  |

#### *思路：*（自底向上）

##### *建立大根堆：*

（1）根据上述初始序列构造完全二叉树，得到如下二叉树：

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240531204154970.png" alt="image-20240531204154970" style="zoom:67%;" />

（2）从最后一个非终端节点开始进行检查，该二叉树的最后一个非终端节点为 09 ，由于节点 09 的左孩子比它要大（09 < 32），不满足最大堆的定义，故我们需要将节点 09 与节点 32 交换，交换之后就满足了最大堆的定义。

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240531205255851.png" alt="image-20240531205255851" style="zoom:67%;" />

（3）接下来处理节点 78 ，由于节点 78 的右孩子比它要大（78 < 87），故我们需要交换节点 78 与节点 87 ，交换之后的根节点就大于了它的左右孩子，满足了最大堆的定义。

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240531205745620.png" alt="image-20240531205745620" style="zoom:67%;" />

（4）再之后处理节点 17 ，由于节点 17 比它的两个孩子都要小，故我们需要将它和最大的一个进行交换，即交换节点 17 与节点 45，交换之后就满足了最大堆的定义。

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240531210150686.png" alt="image-20240531210150686" style="zoom:67%;" />

（5）最后就是处理节点 53，与上面的思路一样，我们需要将它和比它大的孩子交换，即与节点 87 交换，但是交换之后破环了下一级的堆，因此还需要将节点 53 与节点 78 交换，这样我们就得到了一个大根堆。

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240531210649070.png" alt="image-20240531210649070" style="zoom:67%;" />

上述二叉树的存储视角：

| 索引 |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 数值 |      |  87  |  45  |  78  |  32  |  17  |  65  |  53  |  09  |

##### *基于大根堆进行排序：*

每一趟将堆顶元素加入有序子序列（与待排序序列中的最后一个元素交换），并将待排序序列再次调整为大根堆（加入有序子序列的元素就不再需要处理了）。

（1）第一趟：将 87 加入有序子序列，即将 87 与 09 交换，然后将剩下的待排序元素序列再次调整为大根堆。 调整为大根堆的思路与之前相同，这里就不在多赘述了。得到的结果为：

| 索引 |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |   8    |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :----: |
| 数值 |      |  78  |  45  |  65  |  32  |  17  |  09  |  53  | **87** |

（2）第二趟：将 78 加入有序子序列，即将 78 与 53交换，然后将剩下的待排序元素序列再次调整为大根堆。得到的结果为：

| 索引 |  0   |  1   |  2   |  3   |  4   |  5   |  6   |   7    |   8    |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :----: | :----: |
| 数值 |      |  65  |  45  |  53  |  32  |  17  |  09  | **78** | **87** |

后续步骤均相同，得到的最终结果为：

| 索引 |  0   |   1    |   2    |   3    |   4    |   5    |   6    |   7    |   8    |
| :--: | :--: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: |
| 数值 |      | **09** | **17** | **32** | **45** | **53** | **65** | **78** | **87** |

#### *算法实现：*

```c++
// 建立大根堆
void BuildMaxHeap(int A[], int len)
{
    for (int i = len/2; i > 0; i--) // 从后往前依次调整所有非终端节点
        HeadAdjust(A, i, len);
}

// 将以 k 为根的子树调整为大根堆
void HeadAdjust(int A[], int k, int len)
{
    A[0] = A[k]; // A[0]暂存子树的根节点
    for (int i = 2*k; i <= len; i *= 2) // 沿key较大的子节点向下筛选
    {
        if (i < len && A[i] < A[i+1])
            i++; // 取key较大的子节点的下标
        if (A[0] >= A[i])
            break; // 筛选结束
        else
        {
            A[k] = A[i]; // 将A[i]调整到双亲节点上
            k = i; // 修改k值，以便继续向下筛选
        }
    }
    A[k] = A[0]; // 被筛选的节点的值放入最终位置
}

// 堆排序的完整逻辑
void HeapSort(int A[], int len)
{
    BuildMaxHeap(A, len); // 初始建堆
    for (int i = len; i > 1; i--) // n-1趟的交换与建堆过程
    {
        swap(A[i], A[1]); // 堆顶元素和堆底元素交换
        HeadAdjust(A, 1, i-1); // 把剩余待排序元素整理成堆
    }
}
```

#### *算法效率分析：*

#####     ***建堆时间复杂度：***

一个节点，每 “ 下坠 ” 一层，最多只需对比关键字 2 次。

若树高为 h ，某节点再第 i 层，则将这个节点向下调整最多只需要 “ 下坠 ”  h-i 层，关键字对比不超过 2( h-i ) 。

n 个节点的完全二叉树树高 h =  $\left \lfloor   log_2n\right \rfloor + 1$ 。​

第 i 层最多有2 ^i-1^ 个节点，而只有第 1 ~ (h-1) 层的节点才有可能需要 “ 下坠 ” 调整。

将整棵树调整为大根堆，关键字对比次数不超过 ：
$$
\sum_{i=h-1}^{1} 2^{i-1} 2(h-i)=\sum_{i=h-1}^{1} 2^{i}(h-i)=\sum_{j=1}^{h-1} 2^{h-j} j \leq 2 n \sum_{j=1}^{h-1} \frac{j}{2 j} \leq 4 n
$$
**建堆的过程，关键字对比次数不超过 4n ，建堆时间复杂度为 O(n)。**

#####     *排序过程的时间复杂度：*

由于总共需要 n-1 趟，每一趟交换后都需要将根节点 “ 下坠 ” 调整，而每 “ 下坠 ” 一层，最多只需对比关键字 2 次，每一趟排序复杂度不超过 O(h) = O(log~2~n)。因此，**排序过程的时间复杂度为O(nlog~2~n)**。

**综上所述，堆排序的时间复杂度 = O(n) + O(nlog~2~n) = O(nlog~2~n)**

堆排序的空间复杂度 = O(1)

稳定性：不稳定。

**注意：基于大根堆的堆排序得到 “ 递增序列 ”，基于小根堆的堆排序得到 “ 递减序列 ”。**



### 7. 归并排序

#### *归并的思路与过程：*

归并（Merge）：把两个或多个已经有序的序列合并为一个。

使用两个指针 i ，j 指向两个有序序列中的元素，对比所指的元素，选择较小的一个元素放入一个新的的表中。

有序序列1：

| 索引 |  0   |  1   |  2   |  3   |  4   |  5   |  6   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 数值 |  12  |  16  |  24  |  33  |  45  |  56  |  60  |
| 指针 |  i   |      |      |      |      |      |      |

有序序列2：

| 索引 |  0   |  1   |  2   |  3   |  4   |
| :--: | :--: | :--: | :--: | :--: | :--: |
| 数值 |  7   |  10  |  21  |  24  |  37  |
| 指针 |  j   |      |      |      |      |

（1）对比 12 与 7 ，由于 7 < 12，故将 7 加入新的表中，然后 j 指针后移。

| 索引 |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |  10  |  11  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 数值 |  7   |      |      |      |      |      |      |      |      |      |      |      |

有序序列2：

| 索引 |   0   |  1   |  2   |  3   |  4   |
| :--: | :---: | :--: | :--: | :--: | :--: |
| 数值 | **7** |  10  |  21  |  24  |  37  |
| 指针 |       |  j   |      |      |      |

（2）对比 12 与 10，由于 10 < 12，故将10加入新的表中，然后 j 指针后移。

| 索引 |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |  10  |  11  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 数值 |  7   |  10  |      |      |      |      |      |      |      |      |      |      |

有序序列2：

| 索引 |   0   |   1    |  2   |  3   |  4   |
| :--: | :---: | :----: | :--: | :--: | :--: |
| 数值 | **7** | **10** |  21  |  24  |  37  |
| 指针 |       |        |  j   |      |      |

后续步骤均相同，都是对比两个指针所指的元素，并选择较小的一个元素放入新的的表中，然后将指针后移。

只剩一个子表未合并时，可以将该表中剩余元素全部加到总表中。

最终结果为：

| 索引 |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |  10  |  11  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 数值 |  7   |  10  |  12  |  16  |  21  |  24  |  24  |  33  |  37  |  45  |  56  |  60  |

**m 路归并，每选出一个元素需要对比关键字 m-1 次。**

#### *算法思想：*

若给出一个初始序列，那我们就将这个序列中的每一个元素都看作一个个独立的已排好序的部分，然后把相邻的两个部分分别进行 “ 二路 ” 归并，然后在根据这一次归并之后的结果，再次对相邻的两个部分进行归并，重复上述过程，直到归并成一个部分，这时候就完成了归并排序。

核心操作：把数组内的两个有序序列归并为一个。

#### *例题：*

| 索引 |  0   |  1   |  2   |  3   |  4   |  5   |  6   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 数值 |  49  |  38  |  65  |  97  |  76  |  13  |  27  |

#### *思路：*

（1）将上述序列中的每一个元素都看作一个个独立的已排好序的部分，然后把相邻的两个部分分别进行 “ 二路 ” 归并。得到的结果为：

|   索引   |  0   |  1   |  2   |  3   |  4   |  5   |  6   |
| :------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|   数值   |  38  |  49  |  65  |  97  |  13  |  76  |  27  |
| 所属部分 | 表1  | 表1  | 表2  | 表2  | 表3  | 表3  | 表4  |

（2）根据这一次归并之后的结果，接下来再对相邻的两个部分进行归并。得到的结果为：

|   索引   |  0   |  1   |  2   |  3   |  4   |  5   |  6   |
| :------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|   数值   |  38  |  49  |  65  |  97  |  13  |  27  |  76  |
| 所属部分 | 表1  | 表1  | 表1  | 表1  | 表2  | 表2  | 表2  |

（3）此时只剩下了两个子表，继续再对它们进行归并。得到的最终结果为：

| 索引 |  0   |  1   |  2   |  3   |  4   |  5   |  6   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 数值 |  13  |  27  |  38  |  49  |  65  |  76  |  97  |

#### *算法实现：*

```c
// c语言实现
int *B = (int *)malloc(n * sizeof(int)); // 辅助数组B
// A[low...mid] 和 A[mid+1...high] 各自有序，将两个部分归并
void Merge(int A[], int low, int mid, int high)
{
    int i, j, k;
    for (k = low; k <= high; k++)
        B[k] = A[k]; // 将A中所有元素复制到B中
    for (i = low, j = mid+1, k = i; i <= mid && j <= high; k++)
    {
        if (B[i] <= B[j])
            A[k] = B[i++]; // 将较小值复制到A中
        else
             A[k] = B[j++];
    }
    whlie(i <= mid)
        A[k++] = B[i++];
    whlie(j <= high)
        A[k++] = B[j++];
}
// 归并排序
void MergeSort(int A[], int low, int high)
{
    if (low < high)
    {
        int mid = (low + high) / 2; // 从中间划分
        MergeSort(A, low, mid);
        MergeSort(A, mid+1, high); 
        Merge(A, low, mid, high); // 归并
    }
}
```

#### *算法效率分析：*

n 个元素进行 2 路归并排序，**归并趟数 = $\left \lceil   log_2n\right \rceil $**

每趟归并时间复杂度为 O(n)，则算法的**时间复杂度为 O(nlog~2~n)**。

空间复杂度 = **O(n)** ，来自于辅助数组 B 。

稳定性：稳定。



### 8. 基数排序

#### *算法思想：*

假设长度为 n 的线性表中每个节点 a~j~ 的关键字由 d 元组（$k_{j}^{d-1}, k_{j}^{d-2}, k_{j}^{d-3}, \ldots, k_{j}^{1}, k_{j}^{0} $）组成，

其中，$0 \leq k_{j}^{i} \leq \mathrm{r}-1 (0 \leq \mathrm{j}<\mathrm{n}, 0 \leq \mathrm{i} \leq \mathrm{d}-1)$， r 称为 “ 基数 ” 。

基数排序得到递减序列的过程如下，

初始化：设置 r 个空队列，Q~r-1~，Q~r-2~，… ，Q~0~。

按照各个关键字位权重递增的次序（个、十、百），对 d 个关键字位分别做 “ 分配 ” 和 “ 收集 ”。

分配：顺序扫描各个元素，若当前处理的关键字位 = x，则将元素插入 Q~x~ 队尾。

收集：把 Q~r-1~，Q~r-2~，… ，Q~0~ 各个队列中的节点依次出队并链接。

#### *例题：*

要求：得到关键字 “ 递减 ” 的有序序列。

| 索引 |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |  10  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 数值 | 520  | 211  | 438  | 888  | 007  | 111  | 985  | 666  | 996  | 233  | 168  |

#### *思路：*

建立 10 个辅助队列，每一列的取值分别为：9、8、7 … 0。

（1）第一趟 “ 分配 ” ：以个位进行分配

|   辅助队列   |  9   |  8   |  7   |  6   |  5   |  4   |  3   |  2   |  1   |  0   |
| :----------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|     队头     |      | 438  | 007  | 666  | 985  |      | 233  |      | 211  | 520  |
| $\downarrow$ |      | 888  |      | 996  |      |      |      |      | 111  |      |
|     队尾     |      | 168  |      |      |      |      |      |      |      |      |

第一趟 “ 收集 ” ：得到按 “ 个位 ” 递减排序的序列

| 索引 |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |  10  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 数值 | 438  | 888  | 168  | 007  | 666  | 996  | 985  | 233  | 211  | 111  | 520  |

（2）第二趟 “ 分配 ” ：以十位进行分配（ “ 个位 ” 越大的越先入队）

| 辅助队列 |  9   |  8   |  7   |  6   |  5   |  4   |  3   |  2   |  1   |  0   |
| :------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|   队头   | 996  | 888  |      | 168  |      |      | 438  | 520  | 211  | 007  |
|   队尾   |      | 985  |      | 666  |      |      | 233  |      | 111  |      |

第二趟 “ 收集 ” ：得到按 “ 十位 ” 递减排序的序列， “ 十位 ” 相同的按 “ 个位 ” 递减排序

| 索引 |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |  10  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 数值 | 996  | 888  | 985  | 168  | 666  | 438  | 233  | 520  | 211  | 111  | 007  |

（3）第三趟 “ 分配 ” ：以百位进行分配

| 辅助队列 |  9   |  8   |  7   |  6   |  5   |  4   |  3   |  2   |  1   |  0   |
| :------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|   队头   | 996  | 888  |      | 666  | 520  | 438  |      | 233  | 168  | 007  |
|   队尾   | 985  |      |      |      |      |      |      | 211  | 111  |      |

第三趟 “ 收集 ” ：得到按 “ 百位 ” 递减排序的序列， “ 百位 ” 相同的按 “ 十位 ” 递减排序，若 “ 十位 ” 还相同则按 “ 个位 ” 递减排序

| 索引 |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |  10  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 数值 | 996  | 985  | 888  | 666  | 520  | 438  | 233  | 211  | 168  | 111  | 007  |

#### *算法效率分析：*

需要 r 个辅助队列，空间复杂度为 O(r)。

一趟分配O(n)，一趟收集O(r)，总共 d 趟分配、收集，总的时间复杂度为 O(d(n+r))。

稳定性：稳定。

#### *基数排序擅长解决的问题：*

1. 数据元素的关键字可以方便的拆分为 d 组，且 d 较小

2. 每组关键字的取值范围不大，即 r 较小

3. 数据元素个数 n 较大



## 二、数组/链表

### 1.前缀和数组

前缀和技巧适用于快速、频繁地计算一个索引区间内的元素之和。

#### *算法思想：*

我们可以创建一个新的数组 preSum 出来， preSum[ i ] 记录 nums[ 0 … i - 1] 的累加和，这样在计算索引 i 到 j （ i <= j ）范围内的总和时，我们就可以通过 preSum[ j ] - preSum[ i ] 得出，避免了每次进行 for 循环调用。

#### *例题：*

给定下面的整数数组 nums ，求出数组从索引 i 到 j （ i <= j ）范围内的总和，包括 i 、j 两点。

| 索引 |  0   |  1   |  2   |  3   |  4   |  5   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| nums |  3   |  5   |  2   |  -2  |  4   |  1   |

#### *思路：*

创建前缀和数组 preSum ，且 preSum[ i ] = preSum[ i-1 ] + nums[ i-1 ]。

|  索引  |  0   |  1   |  2   |  3   |  4   |  5   |  6   |
| :----: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| preSum |  0   |  3   |  8   |  10  |  8   |  12  |  13  |

#### *算法实现：*

```c++
// 查询闭区间[left, right]的累加和
int sumRange(int nums[], int size, int left, int right)
{
    vector<int> preSum(size + 1, 0);
    for (int i = 1; i <= size; i++) // 构造前缀和数组
        preSum[i] = preSum[i-1] + nums[i-1];
    return preSum[right+1] - preSum[left];
}
```



### 2.差分数组

差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。

#### *算法思想：*

类似前缀和技巧构造的 preSum 数组，我们先对 nums 数组构造一个 diff 差分数组， diff[ i ]就是 nums [ i ] 和 nums[ i - 1] 只差。这样我们就可以快速进行区间增减的操作，若想对区间 nums[ i … j ] 的元素全部加 3 ，那么只需要让 diff [ i ] += 3 ，然后再让 diff [ j + 1 ]   -= 3 即可。

原理很简单， 回想 diff 数组反推 nums 的过程，diff [ i ] += 3 相当于给 nums[ i … ] 所有元素都加了 3 ，而diff [ j + 1 ] -= 3 相当于对 nums[ j + 1 … ] 所有元素再减去 3 ，综合起来，nums[ i … j ] 的元素就都加了 3 。

#### *例题：*

| 索引 |  0   |  1   |  2   |  3   |  4   |
| :--: | :--: | :--: | :--: | :--: | :--: |
| nums |  8   |  2   |  6   |  3   |  1   |

#### *思路：*

创建差分数组 diff ，且 diff[ i ] = nums [ i ] - nums[ i - 1] 。

| 索引 |  0   |  1   |  2   |  3   |  4   |
| :--: | :--: | :--: | :--: | :--: | :--: |
| diff |  8   |  -6  |  4   |  -3  |  -2  |

通过这个差分数组我们是可以反推处原始数组的，nums [ i ] = diff [ 0 ] + diff [ 1 ] + … + diff [ i ]。

#### *算法实现：*

```c++
void Difference(int nums[], int size, int left, int right, int val)
{
    vector<int> diff(size, 0);
    // 构造差分数组
    diff[0] = nums[0];
    for (int i = 1; i < size; i++)
        diff[i] = nums[i] - nums[i - 1];
    // 增加值到差分数组
    diff[left] += val;
    if (right+1 < size)
        diff[right + 1] -= val;
    // 根据差分数组还原到原数组
    nums[0] = diff[0];
    for (int i = 1; i < size; i++)
        nums[i] = nums[i - 1] + diff[i];
}
```



## 三、队列/栈

## 四、二叉树

## 五、图论

### 1. BFS 与 DFS

#### BFS（广度优先遍历）：

对于树，广度优先搜索遍历就是它的层序遍历，即从从根节点开始一层一层的访问所有节点。

1. 若树非空，则根节点入队。
2. 若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队。
3. 重复第（2）步直到队列为空。

对于图，我们也可以使用类似的方法实现它的广度优先搜索遍历。图的广度优先搜索遍历的要点包括：

- 找到与一个顶点相邻的所有顶点。
- 需要一个标记数组来标记哪些顶点被访问过。
- 需要一个辅助队列。

##### 代码实现：

```c++
vector<bool> visited(MAX_VERTEX_NUM, false); // 访问标记数组(初始化为false)
void BFSTravese(Graph G)
{
    InitQueue(Q); // 初始化辅助队列Q
    for (int i = 0; i < G.vexnum; i++) // 从0号节点开始遍历
        if (!visited[i]) // 对每个连通分量调用一次BFS
            BFS(G, i); // vi未访问过，从vi开始BFS
}
// 广度优先搜索遍历
void BFS(Graph G, int v) // 从顶点v出发，广度优先遍历图G
{
    visit(v); // 访问初始顶点v
    visited[v] = true; // 对v做出已访问标记
    Enqueue(Q, v); // 顶点v入队列Q
    while (!isEmpty(Q))
    {
        Dequeue(Q, v); // 顶点v出队列
        for (w = FirstNeighbor(G, v); w >= 0; w = NextNeighbor(G, v, w))
        {
            // 检测v的所有邻接点
            if (!visited[w]) // w为v尚未访问的邻接顶点
            {
                visit(w); // 访问顶点w
                visited[w] = true; //对w做出已访问标记
                Enqueue(Q, v); // 顶点w入队列Q
            }
        }
    }
}
```

##### 复杂度分析：

时间复杂度：对于使用邻接矩阵存储的图，该算法的时间复杂度为 O(V^2^)

​		     对于使用邻接表存储的图，该算法的时间复杂度为 O(V+E)

空间复杂度：由于需要使用一个辅助队列，空间复杂度的大小就取决于这个队列的大小，最坏情况是 O(V)

#### DFS（深度优先遍历）：

深度优先遍历其实就是 “ 一条路走到黑 ”。

对于树，深度优先搜索遍历就是它的先序遍历，即按照 “ 根 - 左 - 右 ” 的顺序访问所有节点。

1. 若树非空，则从根节点开始进行访问。
2. 然后访问根节点的左孩子，并以左孩子作为新的根节点，访问新的左孩子，直到根节点的左孩子为空或者已访问过，然后就按照相同的方法访问右孩子，直到所有节点均被访问过。

对于图，我们也可以使用类似的方法实现它的深度优先搜索遍历。图的深度优先搜索遍历的要点包括：

- 遍历过程中要沿着某一条路径访问顶点，直到与当前顶点相连接的顶点都已经被访问过，然后就回退到上一个节点，寻找其它访问路径。
- 需要一个标记数组来标记哪些顶点被访问过。
- 同一个图的邻接表和邻接矩阵均不唯一，因此深度优先遍历序列也不唯一。

##### 代码实现

```c++
vector<bool> visited(MAX_VERTEX_NUM, false); // 访问标记数组(初始化为false)
void DFSTravese(Graph G)
{
    for (int i = 0; i < G.vexnum; i++) // 本代码是从0号节点开始遍历
        if (!visited[i]) 
           DFS(G, i); 
}
// 深度优先搜索遍历
void DFS(Graph G, int v) // 从顶点v出发，深度优先遍历图G
{
    visit(v); // 访问初始顶点v
    visited[v] = true; // 对v做出已访问标记
    for (w = FirstNeighbor(G, v); w >= 0; w = NextNeighbor(G, v, w))
    {
        if (!visited[w]) // w为v尚未访问的邻接顶点
        {
			DFS(G, w); // 进入下一层递归
        }
    }
}
```

##### 复杂度分析：

时间复杂度 = 访问各节点所需时间 + 探索各条边所需时间

时间复杂度：对于使用邻接矩阵存储的图，该算法的时间复杂度为 O(V^2^)

​		     对于使用邻接表存储的图，该算法的时间复杂度为 O(V+E)

空间复杂度：空间复杂度的大小就取决于递归调用栈，最坏情况是 O(V)，最好情况为 O(1)

### 2.与最小生成树有关的算法

#### prim算法

##### 定义：

从某一个顶点开始构建生成树；每次将代价最小的新顶点纳入，直到所有顶点都纳入为止。

适用于边稠密图。

##### 思路：

从V0开始，总共需要 n-1 轮处理，每一轮处理：循环遍历所有个节点，找到权值最低的，且还没加入树的顶点。然后再次循环遍历，更新还没加入的各个顶点的权值。

对于下面的无向连通图，使用prim算法求出它的最小生成树（从V0开始）：

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240617191518312.png" alt="image-20240617191518312" style="zoom:67%;" />

|            |  V0  |  V1   |  V2   |  V3   |  V4   |  V5   |
| :--------: | :--: | :---: | :---: | :---: | :---: | :---: |
| isJoin[6]  | true | false | false | false | false | false |
| lowCost[6] |  0   |   1   |   4   |   5   |   6   |   5   |

（1）从V0开始，选择与它相连的权值最小的边，这里是V0-V1，它的权值为1，此时V1被加入了生成树中。

|            |  V0  |  V1  |  V2   |  V3   |  V4   |  V5   |
| :--------: | :--: | :--: | :---: | :---: | :---: | :---: |
| isJoin[6]  | true | true | false | false | false | false |
| lowCost[6] |  0   |  1   |   4   |   5   |   6   |   5   |

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240617192050972.png" alt="image-20240617192050972" style="zoom:67%;" />

（2）选择与新的生成树相连的权值最小的边，此时权值最小的边为V0-V2，它的权值为4，然后V2也被加入了生成树中。

|            |  V0  |  V1  |  V2  |  V3   |  V4   |  V5   |
| :--------: | :--: | :--: | :--: | :---: | :---: | :---: |
| isJoin[6]  | true | true | true | false | false | false |
| lowCost[6] |  0   |  1   |  4   | **2** |   6   |   5   |

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240617192333555.png" alt="image-20240617192333555" style="zoom:67%;" />

（3）继续重复上述流程，找出权值最小的与新生成树相连的边，此时为V2-V3，权值为2。

|            |  V0  |  V1  |  V2  |  V3  |  V4   |  V5   |
| :--------: | :--: | :--: | :--: | :--: | :---: | :---: |
| isJoin[6]  | true | true | true | true | false | false |
| lowCost[6] |  0   |  1   |  4   |  2   |   6   |   5   |

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240617192509031.png" alt="image-20240617192509031" style="zoom:67%;" />

由于后续流程均相同，因此就不多赘述了，得到的最终的最小生成树为：

|            |  V0  |  V1  |  V2  |  V3  |  V4  |  V5  |
| :--------: | :--: | :--: | :--: | :--: | :--: | :--: |
| isJoin[6]  | true | true | true | true | true | true |
| lowCost[6] |  0   |  1   |  4   |  2   |  3   |  5   |

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240617192656384.png" alt="image-20240617192656384" style="zoom:67%;" />

该最小生成树的权值之和为：1+2+3+4+5 = 15。

#### kruskal 算法

##### 定义：

每次选择一条权值最小的边，是这条边的两头连通（原本已经连通的就不选），直到所有节点都连通。

适用于边稀疏图。

使用一个并查集将边按权值大小排序，然后进行e轮循环，每轮判断两个顶点是否属于同一个集合。

##### 思路：

对于下面的无向连通图，使用 kruskal 算法求出它的最小生成树：

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240617191518312.png" alt="image-20240617191518312" style="zoom:67%;" />

初始要将各条边按权值进行排序 （并查集）：

| weight  |  1   |  2   |  3   |  4   |  5   |  5   |  5   |  6   |  6   |  6   |
| :-----: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| vertex1 |  V0  |  V2  |  V4  |  V0  |  V0  |  V0  |  V1  |  V0  |  V1  |  V3  |
| vertex2 |  V1  |  V3  |  V5  |  V2  |  V3  |  V5  |  V2  |  V4  |  V5  |  V4  |

（1）从所有的边中找出权值最小的一条，并让它的两端连通，这里最小的是V0-V1，我们就把这两个顶点和这条边加入到生成树中。

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240617192050972.png" alt="image-20240617192050972" style="zoom:67%;" />

（2）继续从剩下的边中找出权值最小的一条，此时最小的是V2-V3。

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240617193918679.png" alt="image-20240617193918679" style="zoom:67%;" />

（3）重复上述步骤，继续找出权值最小的边，如果原本已经连通的，那么就不选。

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240617193931755.png" alt="image-20240617193931755" style="zoom:67%;" />

最终得到的最小生成树为：

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240617192656384.png" alt="image-20240617192656384" style="zoom:67%;" />

该最小生成树的权值之和为：1+2+3+4+5 = 15。

**不连通，连起来，已连通，则跳过。**

### 3.单源最短路径  ——  dijkstra算法

#### 定义：

dijkstra 算法是一个基于贪心、广度优先搜索、动态规划的算法，用于求一个顶点到其它所有顶点的最短路径。

该算法每次从未求出最短路径的点中取出距离起点最小路径的点，以这个点作为桥梁刷新未求出最短路径的点的距离。

#### 思路：

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240617202022551.png" alt="image-20240617202022551" style="zoom:67%;" />

初始：从V0开始，初始化三个数组 final 数组（用于标记各顶点是否已找到最短路径），dist 数组（记录最短路径长度），path 数组（用于记录路径上的前驱）。

|           | V~0~ | V~1~  |   V~2~   |   V~3~   | V~4~  |
| :-------: | :--: | :---: | :------: | :------: | :---: |
| final [5] | true | false |  false   |  false   | false |
| dist [5]  |  0   |  10   | $\infty$ | $\infty$ |   5   |
| path [5]  |  -1  |   0   |    -1    |    -1    |   0   |

（1）第一轮：循环遍历所有顶点，找到还没确定最短路径，且 dist 最小的顶点 V~i~，令 final [ i ] = true。此时最小的顶点为 V~4~，就让这个顶点作为桥梁来刷新剩下顶点的最短路径。

|           |  V0  |  V1   |  V2   |  V3   |  V4  |
| :-------: | :--: | :---: | :---: | :---: | :--: |
| final [5] | true | false | false | false | true |
| dist [5]  |  0   |   8   |  14   |   7   |  5   |
| path [5]  |  -1  |   4   |   4   |   4   |  0   |

（2）第二轮：和第一轮一样循环遍历所有顶点，找到还没确定最短路径，且 dist 最小的顶点 V~i~，此时最小的是V~3~。

|           |  V0  |  V1   |  V2   |  V3  |  V4  |
| :-------: | :--: | :---: | :---: | :--: | :--: |
| final [5] | true | false | false | true | true |
| dist [5]  |  0   |   8   |  13   |  7   |  5   |
| path [5]  |  -1  |   4   |   3   |  4   |  0   |

（3）第三轮：继续上述步骤，此时最小的是V~1~。

|           |  V0  |  V1  |  V2   |  V3  |  V4  |
| :-------: | :--: | :--: | :---: | :--: | :--: |
| final [5] | true | true | false | true | true |
| dist [5]  |  0   |  8   |   9   |  7   |  5   |
| path [5]  |  -1  |  4   |   1   |  4   |  0   |

（4）第四轮：此时只剩下了一个顶点未找到最短路径，我们只需要修改它的 final 数组对应的值即可得到最终结果：

|           |  V0  |  V1  |  V2  |  V3  |  V4  |
| :-------: | :--: | :--: | :--: | :--: | :--: |
| final [5] | true | true | true | true | true |
| dist [5]  |  0   |  8   |  9   |  7   |  5   |
| path [5]  |  -1  |  4   |  1   |  4   |  0   |

**注意：对于含有负权值的带权图，dijkstra算法并不适用。**

### 4.各顶点间的最短路径  ——  floyd 算法

#### 定义：

floyd算法用于求出每一对顶点之间的最短路径。它是一个使用了动态规划思想的典型算法，它把问题的求解分解为了多个阶段。

#### 思路：

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240617215705730.png" alt="image-20240617215705730" style="zoom:67%;" />

初始化：我们需要初始化两个二维数组，一个A(-1)用于记录当前情况下各顶点之间的最短路径长度，一个path(-1)用于记录两个顶点之间的中转点。

#初始：不允许在其它顶点中转的最短路径为：

| A(-1) |  V0  |    V1    |  V2  |      | path(-1) |  V0  |  V1  |  V2  |
| :---: | :--: | :------: | :--: | ---- | :------: | :--: | :--: | :--: |
|  V0   |  0   |    6     |  13  |      |    V0    |  -1  |  -1  |  -1  |
|  V1   |  10  |    0     |  4   |      |    V1    |  -1  |  -1  |  -1  |
|  V2   |  5   | $\infty$ |  0   |      |    V2    |  -1  |  -1  |  -1  |

#0：允许在V0中转，最短路径为：（求A(0) 和 path(0)）

| A(0) |  V0  |   V1   |  V2  |      | path(0) |  V0  |  V1   |  V2  |
| :--: | :--: | :----: | :--: | ---- | :-----: | :--: | :---: | :--: |
|  V0  |  0   |   6    |  13  |      |   V0    |  -1  |  -1   |  -1  |
|  V1  |  10  |   0    |  4   |      |   V1    |  -1  |  -1   |  -1  |
|  V2  |  5   | **11** |  0   |      |   V2    |  -1  | **0** |  -1  |

#1：允许在V0，V1中转，最短路径为：（求A(1) 和 path(1)）

| A(1) |  V0  |  V1  |   V2   |      | path(1) |  V0  |  V1  |  V2   |
| :--: | :--: | :--: | :----: | ---- | :-----: | :--: | :--: | :---: |
|  V0  |  0   |  6   | **10** |      |   V0    |  -1  |  -1  | **1** |
|  V1  |  10  |  0   |   4    |      |   V1    |  -1  |  -1  |  -1   |
|  V2  |  5   |  11  |   0    |      |   V2    |  -1  |  0   |  -1   |

#2：允许在V0，V1，V2 中转，最短路径为：（求A(2) 和 path(2)）

| A(2) |  V0   |  V1  |  V2  |      | path(2) |  V0   |  V1  |  V2  |
| :--: | :---: | :--: | :--: | ---- | :-----: | :---: | :--: | :--: |
|  V0  |   0   |  6   |  10  |      |   V0    |  -1   |  -1  |  1   |
|  V1  | **9** |  0   |  4   |      |   V1    | **2** |  -1  |  -1  |
|  V2  |   5   |  11  |  0   |      |   V2    |  -1   |  0   |  -1  |

从 A(-1) 和 path(-1) 开始，经过 n 轮递推，得到 A(n-1) 和 path(n-1)。

**注意：floyd 算法可以用于带负权值的无回路的图。**

### 5.拓扑排序

#### AOV网：

 AOV 网（用顶点表示活动的网）：用 DAG  图（有向无环图）表示一个工程，顶点表示活动，有向边   <V~i~,V~j~> 表示活动 V~i~ 必须先于活动 V~j~ 进行。（重点：不能存在环路）。

#### 拓扑排序（找到做事的先后顺序）：

在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足以下条件时，称为该图的一个拓扑排序：

- 每个顶点出现且只出现一次。
- 若顶点 A 在序列中排在顶点 B 的前面，则在图中不存在从顶点 B 到 顶点 A 的路径。

#### 拓扑排序的实现：

1. 从 AOV 网中选择一个没有前驱（入度为 0 ）的顶点并输出。
2. 从网中删除该顶点和所有以它为起点的有向边。
3. 重复前两个步骤直到当前的 AOV 网为空或当前网中不存在无前驱的顶点为止。

#### 思路：

对于下面的有向无环图，求出它的一个拓扑排序。

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240618210214107.png" alt="image-20240618210214107" style="zoom:67%;" />

第一步：给出各个顶点的入度：

| 顶点 |  V0  |  V1  |  V2  |  V3  |  V4  |
| :--: | :--: | :--: | :--: | :--: | :--: |
| 入度 |  0   |  1   |  2   |  2   |  0   |

第二步：由于 V0 和 V4 的入度均为 0，这里我们选择从 V0 开始进行拓扑排序，因此就把 V0 顶点加入结果队列中，并把以它为起点的有向边也删去。剩余的顶点的入度为：

| 顶点 |  V1  |  V2  |  V3  |  V4  |
| :--: | :--: | :--: | :--: | :--: |
| 入度 |  0   |  2   |  2   |  0   |

第三步：此时的 V1 和 V4 的入度均为 0 ，这里我们选择把 V1 加入到结果队列中去，并把以 V1为起点的有向边删去，得到剩余节点的入度为：

| 顶点 |  V2  |  V3  |  V4  |
| :--: | :--: | :--: | :--: |
| 入度 |  1   |  2   |  0   |

第四步：此时只剩下了 V4 的入度为 0 ，因此把 V4 加入到结果队列中去，并把以 V4为起点的有向边删去，得到剩余节点的入度为：

| 顶点 |  V2  |  V3  |
| :--: | :--: | :--: |
| 入度 |  0   |  1   |

第五步：最后只剩下了 V2 和 V3 ，由于 V2 的入度为 0 ，故把 V2 加入到结果队列中去，并把以 V2为起点的有向边删去，然后再把剩余的 V3 也加入到结果队列中，这样就得到了最终的结果：

V0 —> V1 —> V4 —> V2 —> V3。

注意：若在某一步出现所有顶点的入度均大于 0 ，那么就说明该图存在回路，无法进行拓扑排序。



## 六、字符串

### *定义：*

字符串是一种用于存储文本数据的数据类型，用于表示字符序列。C++ 提供了 string 类来处理字符串，它位于头文件 <string> 中。string 类提供了丰富的字符串操作功能，包括创建、访问、修改、搜索、连接等。

### *相关操作：*

构造函数：string（长度，初值）。

输入：

```c++
string s;
char buf[100];
cin >> s; // 使用 cin ，直接操作字符串
scanf("%s", &buf); // 使用 scanf ，只能输入到字符数组中，不能直接操作字符串。
s = buf; // 将字符数组赋给字符串
```

索引访问：与数组一样，从 0 开始，使用 s [ i ] 来查找相应字符。

判断两个字符串是否相同：if ( s1 == s2 ) 使用 “ == ” 符号进行判断。

字符串连接：使用 “ + ” 号来连接两个字符串。

取子串：substr（起始下标，子串长度）。这里与 Java 不同， Java 的第二个参数为 终点下标，需要把它们区分开来。

查找字符串：find（字符串，起始下标）。该方法是由暴力算法实现的，时间复杂度为 O ( n^2^ )，如果要优化的话可以通过KMP算法来实现。这样可以有效降低时间复杂度到 O ( n ) 。

#### 数值与字符串互转（C++11）

| 源                                             | 目的        | 函数         |
| ---------------------------------------------- | ----------- | ------------ |
| int / long long / float / double / long double | string      | to_string () |
| string                                         | int         | stoi ()      |
| string                                         | long long   | stoll ()     |
| string                                         | float       | stof ()      |
| string                                         | double      | stod ()      |
| string                                         | long double | stold()      |



## 七、回溯算法

### *定义：*

回溯算法是一种通过穷举来解决问题的方法，它的核心思想是从一个初始状态出发，暴力搜索所有可能的解决方案，当遇到正确的解则将其记录，直到找到解或者尝试了所有可能的选择都无法找到解为止。回溯算法通常采用 ” 深度优先搜索 “ 来遍历解空间。

### *尝试与回退：*

之所以称之为回溯算法，是因为该算法在搜索解空间是会采用 ” 尝试 “ 与 ” 回退 “ 的策略。当算法在搜索过程中遇到某个状态无法继续前进或无法得到满足条件的解时，它会撤销上一步的选择，退回到之前的状态，并尝试其它可能的选择。

### *剪枝：*

复杂的回溯问题通常包含一个或多个约束条件，约束条件通常可用于 ” 剪枝 “ 。 ” 剪枝 “ 是一个非常形象的名词。在搜索过程中，我们 ” 剪掉 “ 了不满足约束条件的搜索分支，避免许多无意义的尝试，从而提高了搜索效率。

### *回溯算法框架：*

```c++
void backtrack(State *state, vector<Choice *> &choices, vector<State *> &res)
{
    if (isSolution(state)) // 判断是否为解
    {
        recordSolution(state, res); // 记录解
        return; // 不再继续搜索
    }
    for (Choice choice : choices) // 遍历所有选择
    {
        if (isValid(state, choice)) // 剪枝：判断选择是否合法
        {
            makeChoice(state, choice); // 尝试：做出选择，更新状态
            backChoice(state, choice, res); // 进入下一层递归
            undoChoice(state, choice); // 回退：撤销选择，恢复到之前的状态
        }
    }
}
```

### *优点与局限性：*

回溯算法本质上是一种深度优先搜索算法，**它尝试所有可能的解决方案直到找到满足条件的解**。这种方法的有点在于能够找到所有可能的解决方案，而且在合理的剪枝操作下，具有很高的效率。

然而，在处理大规模或者复杂问题时，回溯算法的运行效率可能难以接受。

- 时间：回溯算法通常需要遍历状态空间的所有可能，时间复杂度可以达到指数阶或阶乘阶。


- 空间：时间复杂度在递归调用中通常需要保存当前的状态（例如路径、用于剪枝的辅助变量等），当深度很大时，空间需求可能变得很大。

即使如此，**回溯算法依然是某些搜索问题和约束满足问题的最佳解决方案**。对于这些问题，由于无法预测哪些选择可生成有效的解，因此我们必须对所有可能的选择进行遍历。在这种情况下，**关键是如何优化效率**，常见的效率优化有两种。

- **剪枝**：避免搜索那些肯定不会产生解的路径，从而节省时间和空间。

- **启发式搜索**：在搜索过程中引入一些策略或者估计值，从而优先搜索最有可能产生有效解的路径。

### *例题1：全排列问题*

全排列问题是回溯算法的一个典型应用。它的定义是在给定一个集合（如一个数组或字符串）的情况下，找出其中元素的所有可能的排列。

#### *无相等元素的情况：*

##### *问题：*

输入一个整数数组，其中不包含重复元素，返回所有的可能的排列。

##### *思路：*

我们可以把生成排列的过程想象成一系列选择的结果。尝试过程就是做出一个选择，然后进入下一层递归，回退过程就是撤销一个选择，然后继续尝试其它的选择。具体实现方面，我们可以创建状态 state 数组，记录目前已选择的元素；一个候选集合 choices ，用于给出数组中的所有元素；以及一个布尔型数组 selected ，用于记录对应的元素是否已经被选择。需要注意的是，这个 selected 数组就是用于剪枝的，在我们做出选择 choice[ i ] 之后，我们就将 selected[ i ] 修改为 true ，代表它已经被选择，然后再后续遍历列表 choices 的时候，我们就会跳过这些已经被选择的节点，这就是剪枝操作。

##### *代码实现：*

```c++
void backtrack(vector<int> &state, const vector<int> &choices, vector<bool> &selected,  vector<vector<int> > &res)
{
    //当状态长度等于元素数量时，记录解(base case)
    if (state.size() == choices.size())
    {
        res.push_back(state);
        return;
    }
    // 遍历所有选择
    for (int i = 0; i < choices.size(); i++)
    {
        int choice = choices[i];
        // 剪枝：不允许选择重复元素
        if (!selected[i])
        {
            // 尝试：做出选择，更新状态
        	selected[i] = true;
        	state.push_back(choice);
        	// 进入下一层递归，做下一个选择
        	backtrack(state, choices, selected, res);
        	// 回退：撤销选择，恢复到之前的状态
        	selected[i] = false;
        	state.pop_back();
        }
    }
}
```

#### *有相等元素的情况：*

##### *问题：*

输入一个整数数组，数组中可能包含重复元素，返回所有不重复的排列。

##### *思路：*

本题与前面那题的思路类似，但是由于加入了重复的元素，因此会出现重复的排列，那么我们就要想方法去掉这些重复的排列。这里最直接的方法就是考虑借助一个哈希表，直接对排列结果进行去重，但是这样的效率非常低，进行了很多不必要的搜索。更好的方法是在提前识别并剪枝，我们只需要在某一轮选择中保证多个相同元素仅仅被选择依次，这样即可省去很多不必要的搜索。

##### *代码实现：*

```c++
void backtrack(vector<int> &state, const vector<int> &choices, vector<bool> &selected,  vector<vector<int> > &res)
{
    //当状态长度等于元素数量时，记录解(base case)
    if (state.size() == choices.size())
    {
        res.push_back(state);
        return;
    }
    // 遍历所有选择
    unordered_set<int> duplicated; // 使用一个哈希表来记录不重复的元素
    for (int i = 0; i < choices.size(); i++)
    {
        int choice = choices[i];
        // 剪枝：不允许选择重复元素
        if (!selected[i] && duplicated.find(choice) == duplicated.end())
        {
            // 尝试：做出选择，更新状态
            duplicated.emplace(choice); // 记录选择过的元素值
        	selected[i] = true;
        	state.push_back(choice);
        	// 进入下一层递归，做下一个选择
        	backtrack(state, choices, selected, res);
        	// 回退：撤销选择，恢复到之前的状态
        	selected[i] = false;
        	state.pop_back();
        }
    }
}
```

#### *两种剪枝对比：*

在上面两道题中，尽管 selected 和 duplicated 都用于剪枝，但是它们的目标并不同。

- 重复选择剪枝：整轮搜索过程中只有一个 selected 。它记录的是当前状态中包含那些元素，其作用是避免某个元素在 state 中重复出现。
- 相等元素剪枝：每轮选择（每个调用的 backtrack 函数）都包含一个duplicated 。它记录的是在本轮遍历（for 循环）中那些元素已经被选择过，其作用是保证相等元素只被选择一次。

### *例题2：子集和问题*

#### *无重复元素的情况：*

##### *问题：*

给定一个正整数数组 nums 和一个目标正整数 target ，请找出所有可能的组合，使得组合中的元素和等于 target 。给定数组无重复元素，每个元素可以被选取多次。请以列表形式返回这些组合，列表中不应包含重复元素。

##### *思路：*

子集和问题的求解方法类似于全排列解法，我们可以把子集的生成过程想象成一系列选择的结果，并在选择过程中实时更新   “ 元素和 “，当元素和等于 target 时，就将子集记录至结果列表。但是与全排列问题不同的是，本题集合中的元素可以被无限次选取，因此无需借助 selected 布尔列表来记录元素是否被选择。此外，由于集合不存在次序，因此  [4, 5] 与 [5, 4] 这样的结果其实是相同的，因此我们要想办法通过剪枝对搜索过程去重，当做出选择 x~i~ 后，设定下一轮从索引 i 开始遍历，这样就可以让选择序列满足子集唯一。这里有一个需要注意的内容，choices 数组应该是有序递增的。

##### *代码实现：*

```c++
void backtrack(vector<int> &state, int target, vector<int> &choices, int start, vector<vector<int> > &res)
{
    // 子集和等于 target 时，记录解(base case)
    if (target == 0)
    {
        res.push_back(state);
        return;
    }
    // 遍历所有选择
    // 从 start 开始遍历，避免生成重复子集
    for (int i = start; i < choices.size(); i++)
    {
        // 若子集和超过 target ，则直接结束循环
        // 因为 choices 数组是有序的递增的，位于后面的元素更大，子集和必定会超过 target
        if (target - choices[i] < 0)
        {
            break;
        }
        // 尝试：做出选择，更新 target 和 start
        state.push_back(choices[i]);
        // 进行下一轮选择
        backtrack(state, target - choices[i], choices, i, res);
        // 回退：撤销选择，恢复之前的状态
        state.pop_back(state);
    }
}
```

#### *有重复元素的情况：*

##### *问题：*

给定一个正整数数组 nums 和一个目标正整数 target ，请找出所有可能的组合，使得组合中的元素和等于 target 。给定数组可能包含重复元素，每个元素只可被选取一次。请以列表形式返回这些组合，列表中不应包含重复元素。

##### *思路：*

相比于上一题，本题输入的数组可能包含重复元素，这样可能会出现相等元素在某一轮中被多次选择。为了解决这个问题，我们需要限制相等元素在每一轮中只能被选择一次。具体实现的思路为：由于数组是有序递增的，因此相等元素是相邻的 ，这意味着若当前元素与其左边元素相等，则说明它已经被选择过，因此直接跳过当前元素。此外，本题还规定每个数组元素只能被选择一次，我们可以考虑使用 start 来满足该约束条件：当做出选择 x~i~ 后，设定下一轮从索引 i + 1 开始遍历，这样既可以去除重复子集，又可以避免重复选择元素。

##### *代码实现：*

```c++
void backtrack(vector<int> &state, int target, vector<int> &choices, int start, vector<vector<int> > &res)
{
    // 子集和等于 target 时，记录解(base case)
    if (target == 0)
    {
        res.push_back(state);
        return;
    }
    // 遍历所有选择
    // 从 start 开始遍历，避免生成重复子集，同时避免重复选择同一元素
    for (int i = start; i < choices.size(); i++)
    {
        // 若子集和超过 target ，则直接结束循环
        // 因为 choices 数组是有序的递增的，位于后面的元素更大，子集和必定会超过 target
        if (target - choices[i] < 0)
        {
            break;
        }
        // 如果该元素与左边元素相等，说明该搜索分支重复，直接跳过
        if (i > start && choices[i] == choices[i-1])
        {
            continue;
        }
        // 尝试：做出选择，更新 target 和 start
        state.push_back(choices[i]);
        // 进行下一轮选择
        backtrack(state, target - choices[i], choices, i+1, res);
        // 回退：撤销选择，恢复之前的状态
        state.pop_back(state);
    }
}
```

### *例题3：n皇后问题*

#### *问题：*

#### *思路：*

#### *代码实现：*



## 八、动态规划

### *定义：*

动态规划是一个重要的算法范式，它将一个问题分解为一系列更小的子问题，并通过存储子问题的解来避免重复计算，从而大幅提升时间效率。

### *动态规划与记忆化搜索：*

- 动态规划是一种 “ 从底至顶 ” 的方法：从最小子问题的解开始，迭代地构建更大子问题的解，直至得到原问题的解。

- 记忆化搜索是一种 “ 从顶至底 ” 的方法：我们从原问题（根节点）开始，递归地将较大子问题分解为较小子问题，直至解已知的最小子问题（叶节点）。之后，通过回溯逐层收集子问题的解，构建出原问题的解。

- 由于动态规划不包含回溯过程，因此只需要使用循环迭代实现，无需使用递归。我们一般初始化一个数组 dp 来存储子问题的解，它起到了与记忆化搜索中数组 mem 相同的记录作用。

### *动态规划常用术语：*

- 动态规划与回溯算法一样，也使用 “ 状态 ” 概念来表示问题求解的特定阶段，每一个状态都对应一个子问题以及相应的局部最优解。

- 数组 dp 称为 **dp 表**，dp [ i ] 表示状态 i 对应子问题的解。
- 将最小子问题对应的状态（第1阶和第2阶楼梯）称为**初始状态**。
- 将递推公式 dp [ i ] = dp [ i - 1 ] + dp [ i - 2] 称为**状态转移方程**。

### *空间优化：*

由于 **dp [ i ] 只与 dp [ i - 1 ] 和 dp [ i - 2 ] 有关**，因此我们无需使用一个数组 dp 来存储所有子问题的解，而只需要**两个变量滚动前进**即可。

在动态规划问题中，当前状态往往仅与前面有限个状态有关，这时我们可以保留必要的状态，通过 “ 降维 ” 来节省内存空间。这种空间优化技巧被称为 “ 滚动变量 ” 或 “ 滚动数组 ” 。

### *子问题分解：*

子问题分解是一种通用的算法思路，在分治、动态规划、回溯中的侧重点不同。

- **分治算法**递归地将原问题划分为多个相互独立的子问题，直至最小子问题，并在回溯中合并子问题的解，最终得到原问题的解。
- **动态规划**也是对问题进行递归分解，但与分治算法的主要区别是，动态规划中的子问题是相互依赖的，在分解过程中会出现许多重叠子问题。
- **回溯算法**在尝试和回退中穷举所有可能的解，并通过剪枝避免不必要的搜索分支。原问题的解是由一系列决策步骤构成，我们可以将每个决策步骤之前的子问题看作一个子问题。

### *动态规划的两大特性：*

- **最优子结构**：原问题的最优解是从子问题的最优解构建得来的。

- **无后效性**：给定一个确定的状态，它的未来发展只与当前状态有关，而与过去经历的所有状态无关。

### *动态规划解题思路：*

#### 1. *问题判断：*

总的来说，如果一个问题包含重叠子问题、最优子结构，并满足无后效性，那么它通常适合用动态规划求解。然而，我们很难从问题描述中直接提取处这些特性。因此我们通常会放宽条件，**先观察问题是否适合使用回溯（穷举）解决。**

适合使用回溯解决的问题通常满足 **“ 决策树模型 ”**，这些问题可以使用树形结构来描述，其中每一个节点代表一个决策，每一条路径代表一个决策序列。

在此基础上，动态规划问题还有一些判断的 **“ 加分项 ”**。

- 问题包含最大（小）或最多（少）等最优化描述。
- 问题的状态能够使用一个列表、多维矩阵或树来表示，并且一个状态与周围状态存在递推关系。

相应的，也存在一些 **“ 减分项 ”** 。

- 问题的目标是找出所有可能的解决方案，而不是找出最优解。
- 问题描述中有明显的排列组合的特征，需要返回具体的多个方案。

如果一个问题满足决策树模型，而且具有较为明显的 “ 加分项 “ ，我们就可以假设它是一个动态规划问题，并在求解过程中验证它。

#### 2. *问题求解步骤：*

- 思考每轮的决策，定义状态，从而得到 dp 表。
- 找出最优子结构，进而推导出状态转移方程。
- 确定边界条件和状态转移顺序。

### *例题1（0-1背包问题）：*

#### *问题：*

给定 n 个物品，第 i 个物品的重量为 wgt [ i - 1 ] ，价值为 val [ i - 1 ] ，和一个容量为 cap 的背包。每个物品只能选择一次，问在限定背包容量下能放入物品的最大价值。

背包总容量：cap = 50

| 编号 |       i       |  1   |  2   |  3   |  4   |  5   |
| :--: | :-----------: | :--: | :--: | :--: | :--: | :--: |
| 重量 | wgt [ i - 1 ] |  10  |  20  |  30  |  40  |  50  |
| 价值 | val [ i - 1 ] |  50  | 120  | 150  | 210  | 240  |

最大价值：270

最优方案：将物品 2 和物品 3 放入背包，共占用 50 的背包容量。

#### *思路：*

我们可以把 0-1 背包问题看作一个由 n 轮决策组成的过程，对于每个物体都有不放入和放入两种决策，因此该问题满足决策树模型。并且由于该问题的目标是求解 “ 在限定背包容量下能放入物品的最大价值 ” ，因此大概率本题是一个动态规划问题。

##### 第一步：思考每轮决策，定义状态，从而得到 dp 表。

对于每个物品来说，不放入背包，背包容量不变；放入背包中，背包容量变小。由此可得到状态定义：当前物品编号 i 和背包容量 c，记为 [ i , c ] 。

状态 [ i , c ] 对应的子问题为：**前 i 个物品在容量为 c 的背包中的最大价值，记为 dp [ i , c ]。**

待求解的是 dp [ n , cap ] 因此需要一个尺寸为 （n + 1）* （cap + 1）的二维 dp 表。

##### 第二步：找出最优子结构，进而推导出状态转移方程。

当我们做出物品 i 的决策之后，剩余的是前 i - 1 个物品决策的子问题，可以分为以下两种情况。

- 不放入物品 i ：背包容量不变，状态变化为 [ i - 1 , c ] 。
- 放入物品 i ：背包容量减少 wgt [ i - 1 ]，价值增加 val [ i - 1 ]，状态变化为 [ i - 1 , c - wgt [ i - 1 ]]。

上述分析向我们揭示了本题的最优子结构：**最大价值 dp [ i , c ] 等于不放入物品 i 和放入物品 i 两种方案中价值更大的那一个。**由此可以推导出状态转移方程：
$$
dp [i,c]=max(dp[i-1,c],dp[i-1,c-wgt[i-1]]+val[i-1])
$$
需要注意的是，若当前物品重叠 wgt [ i - 1 ] 超出剩余背包容量 c ，则只能选择不放入背包。

##### 第三步：确定边界条件和状态转移顺序。

当无物品或背包容量为 0 是最大价值为 0 ，即首列 dp [ i , 0 ] 和首行 dp [ 0 , c ] 都等于 0 。

当前状态 [ i , c ] 从上方的状态 [ i - 1 , c ] 和左上方的状态 [ i - 1 , c - wgt [ i - 1 ]] 转移而来，因此通过两层循环正序遍历整个 dp 表即可。 

#### *代码实现：*

```c++
// 0-1背包问题：动态规划
int knaosackDP(vector<int> &wgt, vector<int> &val, int cap)
{
    int n = wgt.size();
    // 初始化 dp 表
     vector<vector<int> > dp(n + 1, vector<int>(cap + 1, 0));
    // 状态转移
    for (int i = 1; i <= n; i++)
    {
        for (int c = 1; c <= cap; c++)
        {
            if (wgt[i - 1] > c) // 若超过了背包容量，则不选择该物品
            {
                dp[i][c] = dp[i - 1][c];
            }
            else // 不选和选择物品 i 这两种方案的较大值
            {
                dp[i][c] = max(dp[i - 1][c], dp[i - 1][c - wgt[i - 1]] + val[i - 1]);
            }
        }
    }
    return dp[n][cap]; // 返回将所有物品放入背包的最大价值
}
```

#### *空间优化：*

由于每个状态都只与其上一行的状态有关，因此我们可以使用两个数组滚动前进，将空间复杂度从 O(N^2^) 降低至 O(N)。

进一步思考，我们能否仅用一个数组实现空间优化呢？观察可知，每个状态都是由正上方或左上方的格子转移过来的。假设只有一个数组，当开始遍历第 i 行时，该数组存储的仍然是第 i - 1 行的状态。

- 如果采用正序遍历，那么遍历到 dp [ i ,  j ] 时，左上方 dp [ i - 1 ,  1 ] ~  dp [ i - 1 ,  j - 1] 值可能已经被覆盖，此时就无法得到正确的状态转移结果。
- 如果采取倒序遍历，则不会发生覆盖问题，状态转移可以正确进行。

在代码实现中，我们仅需要将数组 dp 的第一维 i 直接删除，并且把内循环修改为倒序遍历即可。

#### *优化之后的代码实现：*

 ```c++
 // 0-1背包：空间优化之后的动态规划
 int knapsackDPComp(vector<int> &wgt, vector<int> &val, int cap)
 {
     int n = wgt.size();
     // 初始化 dp 表
     vector<int> dp(cap + 1, 0);
     // 状态转移
     for (int i = 1; i <= n; i++)
     {
         // 倒序遍历
         for (int c = cap; c >= 1; c--)
         {
             if (wgt[i - 1] <= c) // 不选和选择物品 i 这两种方案的较大值
             {
                 dp[c] = max(dp[c], dp[c - wgt[i - 1]] + val[i - 1])
             }
         }
     }
     return dp[cap];
 }
 ```

### *例题2（完全背包问题）：*

#### *问题：*

给定 n 个物品，第 i 个物品的重量为 wgt [ i - 1 ] ，价值为 val [ i - 1 ] ，和一个容量为 cap 的背包。每个物品可以重复选取，问在限定背包容量下能放入物品的最大价值。

背包总容量：cap = 50

| 编号 |       i       |  1   |  2   |  3   |  4   |  5   |
| :--: | :-----------: | :--: | :--: | :--: | :--: | :--: |
| 重量 | wgt [ i - 1 ] |  10  |  20  |  30  |  40  |  50  |
| 价值 | val [ i - 1 ] |  50  | 120  | 150  | 210  | 240  |

最大价值：290

最优方案：将一个物品 1 和两个物品 2 放入背包，共占用 50 的背包容量。

#### *思路：*

完全背包问题与 0-1 背包问题非常相似，**区别只在于不限制物品的选择次数**。

- 在 0-1 背包问题中，每种物品只有一个，因此将物品 i 放入背包之后，只能从前 i - 1 个物品中选择。
- 在完全背包问题中，每种物品的数量时无限的，因此价格呢物品 i 放入背包后，**仍可以从前 i 个物品中选择**。

在完全背包问题的规定下，状态 [ i ,  c ] 的变化分为两种情况。

- 不放入物品 i ：与 0-1 背包问题相同，转移至 [ i - 1 ,  c ] 。
- 放入物品 i ：与 0-1 背包问题不同，转移至 [ i ,  c - wgt [ i - 1 ] ] 。

因此，状态转移方程变为：
$$
dp [i,c]=max(dp[i-1,c],dp[i,c-wgt[i-1]]+val[i-1])
$$

#### *代码实现：*

对比两道题目的代码，状态转移中有一处从 i - 1 变为 i ，其余完全一致。

```c++
//完全背包问题：动态规划
int unboundedKnaosackDP(vector<int> &wgt, vector<int> &val, int cap)
{
    int n = wgt.size();
    // 初始化 dp 表
     vector<vector<int> > dp(n + 1, vector<int>(cap + 1, 0));
    // 状态转移
    for (int i = 1; i <= n; i++)
    {
        for (int c = 1; c <= cap; c++)
        {
            if (wgt[i - 1] > c) // 若超过了背包容量，则不选择该物品
            {
                dp[i][c] = dp[i - 1][c];
            }
            else // 不选和选择物品 i 这两种方案的较大值
            {
                dp[i][c] = max(dp[i - 1][c], dp[i][c - wgt[i - 1]] + val[i - 1]);
            }
        }
    }
    return dp[n][cap]; // 返回将所有物品放入背包的最大价值
}
```

#### *空间优化：*

由于当前状态是从左边和上方的状态转移而来的，**因此空间优化后应该对 dp 表中的每一行进行正序遍历**。这个遍历正好与 0-1 背包相反。

#### *优化之后的代码实现：*

```c++
// 完全背包：空间优化之后的动态规划
int unboundedKnaosackDPComp(vector<int> &wgt, vector<int> &val, int cap)
{
    int n = wgt.size();
    // 初始化 dp 表
    vector<int> dp(cap + 1, 0);
    // 状态转移
    for (int i = 1; i <= n; i++)
    {
        // 正序遍历
        for (int c = 1; c <= cap; c++)
        {
            if (wgt[i - 1] > c) // 若超过了背包容量，则不选择该物品
            {
                dp[c] = dp[c];
            }
            else // 不选和选择物品 i 这两种方案的较大值
            {
                dp[c] = max(dp[c], dp[c - wgt[i - 1]] + val[i - 1]);
            }
        }
    }
    return dp[cap];
}
```

### *例题3（零钱兑换问题 I ）：*

#### *问题：*

给出 n 种硬币，第 i 种硬币的面值为 coins [ i - 1 ] ，目标金额为 amt ，每种硬币可以重复选取，问能够凑出目标金额的最少硬币数量。如果无法凑出目标金额，则返回 -1 。

#### *思路：*

**该问题可以看作完全背包问题的一种特殊情况**，两者具有以下联系和不同之处：

- 两道题可以相互转换， “ 物品 ” 对应 “ 硬币 ” ，“ 物品重量 ” 对应 “ 硬币面值 ” ，“ 背包容量 ” 对应 “ 目标金额 ”。
- 优化目标相反，完全背包问题是要求出最大的物品价值，零钱兑换问题是要求出最小的硬币数量。
- 完全背包问题是求 “ 不超过 ” 背包容量下的解，零钱兑换是求 “ 恰好 ” 凑到目标金额的解。

##### **第一步：思考每轮决策，定义状态，得到 dp 表。**

状态 [ i , a ] 对应的子问题为：前 i 种硬币能够凑出金额 a 的最少硬币数量， 记为 dp [ i , a ] 。

二维 dp 表的尺寸为 （n + 1）* （amt + 1）。

##### **第二步：找出最优子结构，进而推导出状态转移方程。**

本题与完全背包问题的状态转移方程存在以下两点差异。

- 本题要求最小值，因此需要将运算符 max() 修改为 min() 。
- 本题的优化主题是硬币数量而不是商品价值，因此在选中硬币时只需要加一即可。

得到的状态转移方程为：
$$
dp [i,a]=min(dp[i-1,a],dp[i,a-coins[i-1]]+1)
$$

##### 第三步：确定边界条件和状态转移顺序。

当目标金额为 0 时，凑出它的最少硬币数量为 0 ，即首列所有 dp [ i , 0 ] 都为 0。

当无硬币时，无法凑出然后大于 0 的目标金额，即为无效解。为了使 min 函数能够过滤这些无效解，我们考虑使用 $ +\infty $ 来表示它们，也即是让首行所有 dp [ 0 , a ] 均为 $ +\infty $ 。又由于大多数语言均没有提供 $ +\infty $ ，因此我们使用 int 的最大值来代替，但是这又可能导致越界问题，发生溢出。为此，我们采用数字 amt + 1 来表示无效解，因为凑出 amt 的硬币数量最多为 amt 。最后返回时，判断          dp [ n , amt ] 是否等于 amt + 1 ，若是则返回 -1 ，代表无法凑出目标金额。

#### *代码求解：*

```c++
// 零钱兑换：动态规划
int coinChangeDP(vector<int> $coins, int amt)
{
    int n = coins.size();
    int MAX = amt + 1;
    // 初始化 dp 表
    vector<vector<int> > dp(n + 1, vector<int>(amt + 1, 0));
    // 状态转移：首行和首列
    for (int a = 1; a <= amt; a++)
    {
        dp[0][a] = MAX;
	}
    // 状态转移：其余行和列
    for (int i = 1; i <= n; i++)
    {
        for (int a = 1; a <= amt; a++)
        {
            if (coins[i - 1] > a) // 若超过目标金额，则不选择该硬币
            {
                dp[i][a] = dp[i - 1][a];
            }
            else // 不选择和选择硬币 i 这两种方案的较小值
            {
                dp[i][a] = min(dp[i - 1][a], dp[i][a - coins[i - 1]] + 1);
            }
        }
    }
    return dp[n][amt] != MAX ? dp[n][amt] : -1; // 判断 dp[n][amt] 是否等于 amt + 1，是的话就返回 -1
}
```

#### *空间优化：*

零钱兑换的空间优化与完全背包问题完全一致，它其实就是一种特殊的完全背包问题。

#### *优化之后的代码实现：*

```c++
// 零钱兑换；经过空间优化的动态规划
int coinChangeDPComp(vector<int> &coins, int amt)
{
    int n = coins.size();
    int MAX = amt + 1;
    // 初始化 dp 表
    vector<int> dp(amt + 1, MAX);
    dp[0] = 0;
    // 状态转移
    for (int i = 1; i <= n; i++)
    {
        for (int a = 1; a <= amt; a++)
        {
            if (coins[i - 1] > a) // 若超过目标金额，则不选择该硬币
                dp[a] = dp[a];
            else // 不选择和选择硬币 i 这两种方案的较小值
                dp[a] = min(dp[a], dp[a - coins[i - 1]] + 1);
		}
    }
    return dp[amt] != MAX ? dp[amt] : -1;
}
```

### *例题4（零钱兑换问题 II ）：*

#### *问题：*

给定 n 种硬币，第 i 种硬币的面值为 coins [ i - 1 ] ，目标金额为 amt，每种硬币可以重复选取，问凑出目标金额的硬币组合数量。

#### *思路：*



#### *代码求解：*



#### *空间优化：*



#### *优化之后的代码实现：*



### *例题5（编辑距离问题）：*

#### *问题：*



#### *思路：*



#### *代码求解：*



#### *空间优化：*



#### *优化之后的代码实现：*



## 九、贪心算法

### *定义：*

贪心算法是一种常见的解决优化问题的算法，其基本思想是在问题的每个决策阶段，都选择当前看起来最优的选择，即贪心地做出局部最优的决策，以期获得全局最优解。贪心算法简介且高效，在许多实际问题中有着广泛的应用。

### *贪心算法与动态规划：*

贪心算法和动态规划都常用于解决优化问题。它们之间存在一些相似之处，比如都依赖**最优子结构性质**。但是它们的工作原理不同。

- 动态规划会根据之前阶段的所有决策来考虑当前决策，并使用过去子问题的解来构建当前子问题的解。
- 贪心算法不会考虑过去的决策，而是一路向前地进行贪心选择，不断缩小问题范围，直至问题被解决。

### *贪心算法的优点与局限性：*

贪心算法不仅操作**直接、实现简单，而且通常效率也很高**。但是，在一些情况下贪心算法**无法保证找到全局最优解**，而且有可能会找到非常差的解。它更适合用动态规划解决。

一般情况下，贪心算法的适用情况分为以下两种。

1. **可以保证找到最优解**：贪心算法在这种情况下往往是最优选择，因为它往往比回溯，动态规划更高效。‘
2. **可以找到近似最优解**：贪心算法在这种情况下也是可用的。对于很多复杂问题来说，寻找全局最优解非常困难，能以较高效率找到次优解也是非常不错的。

### *贪心算法特性：*

相较于动态规划，贪心算法的适用条件更加苛刻，其主要关注问题的两个性质。

- **贪心选择结构**：只有当局部最优选择始终可以导致全局最优解时，贪心算法才能保证得到最优解。对于许多实际问题，证明贪心选择性质并非易事。
- **最优子结构**：原问题的最优解包含子问题的最优解。最优子结构在 “ 动态规划 ” 章节介绍过。需要注意的是，一些问题的最优子结构并不明显，但仍可以用贪心算法解决。

### *贪心算法解题步骤：*

贪心问题的解决流程大体可分为以下三步：

1. 问题分析：梳理和理解问题特性，包括状态定义、优化目标和约束条件等。这一步在回溯与动态规划中都有涉及。
2. 确定贪心策略：确定如何在每一步中做出贪心选择，这个策略能够在每一步中减小问题的规模，并最终解决整个问题。
3. 正确性证明：通常需要证明问题具有贪心选择和最优子结构，这个步骤可能需要用到数学证明，例如归纳法和反证法等。

确定贪心策略是求解问题的核心步骤，但实施起来可能并不容易，主要有以下原因：

1. 不同问题的贪心策略差异较大。对于许多问题来说，贪心策略比较浅显，我们通过一些大概的思考与尝试就能得出。而对于一些复杂问题，贪心策略可能非常隐蔽，这种情况就非常考验个人的解题经验与算法能力了。
2. 某些贪心策略具有较强的迷惑性。当我们满怀信心设计好贪心策略，写出解题代码并提高运行，很可能发现部分测试样例无法通过。这是因为设计的贪心策略只是 “ 部分正确 ” 的，对于一些特殊无法处理。

### *例题：*

```c++

```



## 十、其它

## 算法模板

### 一、前缀和

#### 1. 定义

前缀和是指给定一个数组，我们预先计算出数组每个位置的前缀和。前缀和数组的第 `i` 个元素表示原始数组前 `i` 个元素的和。前缀和可以通过递推公式来计算：

- 设数组为 `arr`，前缀和数组为 `prefix_sum`，则：
  $$
  prefix\_sum[i] = arr[0] + arr[1] + \dots + arr[i-1]
  $$

  或者递推表达式：
  $$
  prefix\_sum[i] = prefix\_sum[i-1] + arr[i-1]
  $$
  

#### 2. 代码模板

```cpp
// 计算前缀和数组
vector<int> prefixSum(const vector<int>& arr) {
    int n = arr.size();
    vector<int> prefix_sum(n + 1, 0); // 初始化前缀和数组，大小为n+1，初始为0
    for (int i = 1; i <= n; i++) {
        prefix_sum[i] = prefix_sum[i - 1] + arr[i - 1]; // 递推计算前缀和
    }
    return prefix_sum;
}

// 计算区间和 [left, right)
int rangeSum(const vector<int>& prefix_sum, int left, int right) {
    return prefix_sum[right] - prefix_sum[left]; // 区间和等于 prefix_sum[right] - prefix_sum[left]
}
```

#### 3. 使用例子

##### 问题：给定一个数组和若干区间，求每个区间的元素和。

**例题：**

给定一个数组 `arr = [1, 2, 3, 4, 5]` 和若干区间 `[1, 3]`，`[0, 2]`，分别求出这些区间的和。

**思路：**

1. 首先计算出数组 `arr` 的前缀和数组。
2. 利用前缀和数组，快速计算出各个区间的和。

##### 代码实现：

```cpp
#include <iostream>
#include <vector>
using namespace std;

// 前缀和函数
vector<int> prefixSum(const vector<int>& arr) {
    int n = arr.size();
    vector<int> prefix_sum(n + 1, 0);
    for (int i = 1; i <= n; i++) {
        prefix_sum[i] = prefix_sum[i - 1] + arr[i - 1];
    }
    return prefix_sum;
}

// 查询区间和
int rangeSum(const vector<int>& prefix_sum, int left, int right) {
    return prefix_sum[right] - prefix_sum[left];
}

int main() {
    // 定义数组
    vector<int> arr = {1, 2, 3, 4, 5};
    
    // 计算前缀和数组
    vector<int> prefix_sum = prefixSum(arr);
    
    // 输出前缀和数组
    cout << "Prefix Sum: ";
    for (int i = 0; i <= arr.size(); i++) {
        cout << prefix_sum[i] << " ";
    }
    cout << endl;

    // 计算区间和
    cout << "Range [1, 3): " << rangeSum(prefix_sum, 1, 3) << endl;  // 输出 5
    cout << "Range [0, 2): " << rangeSum(prefix_sum, 0, 2) << endl;  // 输出 3

    return 0;
}
```

##### 输出结果：

```
Prefix Sum: 0 1 3 6 10 15 
Range [1, 3): 5
Range [0, 2): 3
```

#### 4. 思路解析

1. **前缀和计算**：通过 `prefix_sum[i] = prefix_sum[i-1] + arr[i-1]`，我们预先计算出原始数组每个位置的前缀和，并存储在 `prefix_sum` 数组中。这样可以通过一次遍历完成前缀和的计算，时间复杂度为 `O(n)`。

2. **区间和查询**：利用 `prefix_sum[right] - prefix_sum[left]`，我们可以在 `O(1)` 的时间内快速得到任意区间 `[left, right)` 的和。

#### 5. 优点与局限性

- **优点**：前缀和算法通过预处理大大降低了查询的时间复杂度，在处理大量区间和查询时表现优越，查询时间为常数 `O(1)`。
- **局限性**：需要额外的 `O(n)` 空间来存储前缀和数组。并且在处理多维数据时，计算前缀和的复杂度会更高，需要考虑优化空间占用。



### 二、差分数组

#### 1. 定义

差分数组是一种帮助快速处理区间增量更新的工具。它的核心思想是在原数组的基础上构建一个差分数组，通过在差分数组上做局部修改来实现对原数组的整体区间修改。最终，通过前缀和的方式，可以快速恢复出原数组的值。

- **差分数组构建**：设数组 `arr`，则差分数组 `diff` 满足：
  $$
  diff[i] = arr[i] - arr[i-1]
  $$

  通过差分数组，我们可以快速对某个区间 `[l, r]` 进行加减操作。

- **更新区间**：要对区间 `[l, r]` 增加某个值 `val`，只需要对差分数组进行两次修改：
  $$
  diff[l] += val
  $$

  $$
  diff[r + 1] -= val
  $$

  

  这意味着我们在位置 `l` 开始增加 `val`，而在位置 `r + 1` 开始减去 `val`，从而实现对区间 `[l, r]` 的增量修改。

- **恢复原数组**：通过累加差分数组，我们可以得到更新后的原始数组。

#### 2. 代码模板

```cpp
// 构建差分数组
vector<int> createDiffArray(const vector<int>& arr) {
    int n = arr.size();
    vector<int> diff(n + 1, 0);
    diff[0] = arr[0];
    for (int i = 1; i < n; i++) {
        diff[i] = arr[i] - arr[i - 1];  // 计算差分
    }
    return diff;
}

// 对区间 [l, r] 增加 val
void incrementRange(vector<int>& diff, int l, int r, int val) {
    diff[l] += val;
    if (r + 1 < diff.size()) {
        diff[r + 1] -= val;  // 在 r+1 处进行减去操作
    }
}

// 根据差分数组恢复原始数组
vector<int> restoreArray(const vector<int>& diff) {
    int n = diff.size();
    vector<int> arr(n - 1, 0);
    arr[0] = diff[0];
    for (int i = 1; i < n - 1; i++) {
        arr[i] = arr[i - 1] + diff[i];  // 累加得到原数组
    }
    return arr;
}
```

#### 3. 使用例子

##### 问题：给定一个数组 `arr = [0, 0, 0, 0, 0]`，要求进行若干次区间加法操作，如对区间 `[1, 3]` 增加 `2`，对区间 `[2, 4]` 增加 `3`，然后输出更新后的数组。

**思路：**

1. 先构建差分数组。
2. 进行若干次区间更新，每次修改差分数组的两个位置。
3. 最后通过差分数组恢复出更新后的原数组。

##### 代码实现：

```cpp
#include <iostream>
#include <vector>
using namespace std;

// 构建差分数组
vector<int> createDiffArray(const vector<int>& arr) {
    int n = arr.size();
    vector<int> diff(n + 1, 0);
    diff[0] = arr[0];
    for (int i = 1; i < n; i++) {
        diff[i] = arr[i] - arr[i - 1];
    }
    return diff;
}

// 对区间 [l, r] 增加 val
void incrementRange(vector<int>& diff, int l, int r, int val) {
    diff[l] += val;
    if (r + 1 < diff.size()) {
        diff[r + 1] -= val;
    }
}

// 根据差分数组恢复原始数组
vector<int> restoreArray(const vector<int>& diff) {
    int n = diff.size();
    vector<int> arr(n - 1, 0);
    arr[0] = diff[0];
    for (int i = 1; i < n - 1; i++) {
        arr[i] = arr[i - 1] + diff[i];
    }
    return arr;
}

int main() {
    // 初始化数组
    vector<int> arr = {0, 0, 0, 0, 0};
    
    // 构建差分数组
    vector<int> diff = createDiffArray(arr);
    
    // 进行区间更新
    incrementRange(diff, 1, 3, 2);  // 区间 [1, 3] 增加 2
    incrementRange(diff, 2, 4, 3);  // 区间 [2, 4] 增加 3
    
    // 恢复原始数组
    vector<int> result = restoreArray(diff);
    
    // 输出更新后的数组
    cout << "Updated Array: ";
    for (int num : result) {
        cout << num << " ";
    }
    cout << endl;
    
    return 0;
}
```

##### 输出结果：

```
Updated Array: 0 2 5 5 3 
```

#### 4. 思路解析

1. **差分数组构建**：我们构建了一个差分数组 `diff`，它的长度比原数组 `arr` 多 1，用于记录每个位置的变化。差分数组表示的是相邻元素的差值。

2. **区间增量更新**：通过修改差分数组的局部值，我们实现了对原数组的区间增量更新。具体来说，`diff[l] += val` 表示从位置 `l` 开始增加 `val`，而 `diff[r+1] -= val` 表示从位置 `r+1` 开始恢复回去。

3. **恢复原数组**：最后，通过对差分数组进行前缀和计算，可以快速恢复出原始数组的值。

#### 5. 优点与局限性

- **优点**：差分数组的主要优势在于处理区间增量更新问题时，它的更新操作可以在常数时间内完成，大大提升了效率，适用于需要频繁更新区间的场景。
- **局限性**：差分数组只能处理线性数据的增量更新，无法直接处理乘法、取模等复杂运算场景。









