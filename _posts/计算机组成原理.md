---
layout: post
title: C++ STL个人总结
categories: [Computer Science]
tags: [408, Computer Science]
---

# 计算机组成原理

## 一、计算机系统概述

### 1.1 计算机的发展

#### 什么是计算机系统

**计算机系统 = 硬件 + 软件**

硬件指的是计算机的实体，如主机、外设等。

软件分为系统软件和应用软件。系统软件指的是用于管理整个计算机系统的软件。应用软件指的是按任务需要编制成的各种程序。



#### 硬件发展历程

第一台电子数字计算机：**ENIAC（1946）**占地面积170平方米，耗电量150千瓦，运算速度：5000次加法 / 秒。（**冯诺依曼**）

| 发展阶段 |   时间    |         逻辑元件         | 速度（次/秒） |      内存      |              外存              |
| :------: | :-------: | :----------------------: | :-----------: | :------------: | :----------------------------: |
|  第一代  | 1946-1957 |          电子管          |   几千-几万   | 汞延迟线、磁鼓 |         穿孔卡片、纸带         |
|  第二代  | 1958-1964 |          晶体管          |  几万-几十万  |   磁芯存储器   |              磁带              |
|  第三代  | 1964-1971 |    中小型规模集成电路    | 几十万-几百万 |  半导体存储器  |           磁带、磁盘           |
|  第四代  | 1972-现在 | 大规模、超大规模集成电路 |  上千万-万亿  |  半导体存储器  | 磁盘、磁带、光盘、半导体存储器 |

**机器字长：计算机一次整数运算所能处理的二进制位数。**

1947年，贝尔实验室发明了 ” 晶体管 “

1955年，肖克利在硅谷创建肖克利实验室股份有限公司

1957年，八叛徒创立仙童半导体公司

1959年，仙童半导体发明 ” 集成电路 “

1968年，摩尔等人离开仙童，创建 Intel

1969年，桑德斯创建AMD

摩尔定律：揭示了信息技术进步的速度，集成电路上可容纳的晶体管数目，约每隔18个月便会增加一倍，整体性能也会提升一倍。

#### 软件发展历程

计算机语言的发展经历了面向机器的机器语言和汇编语言、面向问题的高级语言。其中高级语言的发展真正促进了软件的发展，它经历了从科学计算和工程计算的 FORTRAN 、结构化程序设计的 PASCAL 到面向对象的 C++ 和适应网络环境的 Java。

与此同时，直接影响计算机系统性能提升的各种系统软件也有了长足的发展，特别是操作系统，如 Windows、UNIX、Linux。

#### 目前发展趋势

一极是微型计算机向更微型化、网络化、高性能、多用途方向发展；

另一极是巨型化、超高速、并行处理、智能化方向发展。

#### 总结

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240617162638787.png" alt="image-20240617162638787" style="zoom:60%;" />



### 1.2.1 计算机硬件的基本组成

#### 早期冯诺依曼机

**” 存储程序 “** 的概念是指将指令以二进制代码的形式事先输入计算机的主存储器，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其它指令，直到程序执行结束。

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240617163306483.png" alt="image-20240617163306483" style="zoom:60%;" />

**在计算机系统中，软件和硬件在逻辑上是等效的。**

#### 冯诺依曼计算机的特点

1. 计算机由五大部件组成
2. 指令和数据以同等地位存储于存储器，可按地址寻访
3. 指令和数据用二进制表示
4. 指令和数据用二进制表示
5. 存储程序
6. **以运算器为中心**

#### 现代计算机的结构

现代计算机：**以存储器为中心**

CPU = 运算器 + 控制器

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240617164032903.png" alt="image-20240617164032903" style="zoom:67%;" />

#### 总结

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240617164219590.png" alt="image-20240617164219590" style="zoom:60%;" />



### 1.2.2各个硬件的工作原理

#### 主存储器的基本组成

MAR：存储地址寄存器

MDR：存储数据寄存器

数据在存储体内按地址存储。 MAR位数反映存储单元个数，MDR位数 = 存储字长。

**存储单元：每个存储单元存放一串二进制代码**

**存储字：存储单元中二进制代码的组合**

**存储字长：存储单元中二进制代码的位数**

**存储元：即存储二进制的电子元件，每个存储元可存 1 bit**

注意：1B = 1个字节，1b = 一个bit

#### 运算器的基本组成

运算器：用于实现算术运算、逻辑运算。

ACC：累加器，用于存放操作数，或运算结果

MQ：乘商寄存器，在乘除运算时用于存放操作数或运算结果

X：通用的操作数寄存器，用于存放操作数

ALU：算术逻辑单元，通过内部复杂的电路实现算术运算、逻辑运算

|      |     加     |     减     |       乘       |      除      |
| :--: | :--------: | :--------: | :------------: | :----------: |
| ACC  | 被加数、和 | 被减数、差 |    乘积高位    | 被除数、余数 |
|  MQ  |            |            | 乘数、乘积高位 |      商      |
|  X   |    加数    |    减数    |     被乘数     |     除数     |

#### 控制器的基本组成

CU：控制单元，分析指令，给出控制信号

IR：指令寄存器，存放当前执行的指令

PC：程序计数器，存放下一条指令地址，有自动加1功能

完成一条指令：取指令（PC） —> 分析指令（IR） —> 执行指令  (CU)

#### 计算机的工作过程

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240617170607512.png" alt="image-20240617170607512" style="zoom: 50%;" />

初始：(PC) = 0，指向第一条指令的存储地址

#1：(PC)—> MAR，导致  (MAR) = 0

#2：MAR —> 存储体，MAR 在存储体中对应查找主存地址为 0 的指令

#3：M(MAR) —>MDR ，导致 (MDR) = 000001 0000000101

#4：(MDR) —> IR ，导致 (IR) = 000001 0000000101

#5：OP(IR) —> CU ，指令的操作码送到 CU ，CU 分析后得知，这是 ” 取数 “ 指令

#6：Ad(IR) —> MAR ，指令的地址码 MAR ，导致 (MAR) = 5

#7：MAR —> 存储体，MAR 在存储体中对应查找主存地址为 5 的指令

#8：M(MAR) —>MDR ，导致 (MDR) = 0000000000000010 = 2

#9：(MDR) —> ACC ，导致 (ACC) = 0000000000000010 = 2

注：取指令（#1 ~ #4），分析指令（#5），执行取数指令（#6 ~ #9）

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240617171957663.png" alt="image-20240617171957663" style="zoom:80%;" />

上一条指令取指之后 PC 会自动加 1，然后就会继续执行后续的指令。

前面的#1 ~ #5 步骤是必经步骤，而后面不同的指令具体步骤不同。

CPU区分指令和数据的依据：指令周期的不同阶段。

#### 总结 

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240617172916116.png" alt="image-20240617172916116" style="zoom:67%;" />



### 1.2.3 计算机系统的多级层次结构

#### 计算机系统的层次结构

1. 微程序机器 M0 （**微指令系统**）由硬件直接执行微指令：微指令1、微指令3、微指令7…
2. 传统机器 M1 （**用机器语言的机器**）执行二进制机器指令：如0000010000000101（取数指令），0001000000000110（乘法指令）。
3. 虚拟机器 M2 （**操作系统机器**）向上提供 “ 广义指令 ” （系统调用）。
4. 虚拟机器 M3 （**汇编语言机器**）用汇编程序翻译成机器语言程序：如 LOAD 5 ， MUL 6（汇编语言指令和机器语言指令一一对应）。
5. 虚拟机器 M4 （高级语言机器）用翻译程序翻译成汇编语言程序： y = a * b + c 。

下层是上层的基础，上层是下层的扩展。

编译程序：将高级语言编写的源程序全部语句一次全部翻译成机器语言程序，而后再执行机器语言程序（只需要翻译一次）。

解释程序：将源程序的一条语句翻译成对应机器语言的语句，并立即执行。紧接着再翻译下一句（每次执行都要翻译）。

#### 总结

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240621154505021.png" alt="image-20240621154505021" style="zoom:60%;" />



### 1.3 计算机的性能指标

#### 存储器的性能指标

MAR位数反应**存储单元的个数**（最多支持多少个），**MDR位数 = 存储字长 = 每个存储单元的大小**。

**总容量 = 存储单元个数 * 存储字长 bit = 存储单元个数 * 存储字长 / 8 Byte。**

**1 Byte = 8 bit。**

**2^10^ : K      2^20^ : M      2^30^ : G      2^40^ : T**

#### CPU的性能指标

**CPU主频：CPU内数字脉冲信号震荡的频率。**

CPU主频（时钟频率）= $ \frac{1}{CPU时钟周期} $ 。单位：赫兹（Hz）。

CPI：执行一条指令所需的时钟周期数。不同的指令，CPI不同。甚至相同的指令，CPI也可能有变化。

执行一条指令的耗时 = CPI * CPU时钟周期。

CPU执行时间（整个程序的耗时）= CPU时钟周期数 / 主频 = （指令条数 * CPI）/ 主频。

IPS：每秒执行多少条指令。IPS = $ \frac{主频}{平均CPI} $

FLOPS：每秒执行多少次浮点运算。

我们可以在 FLOPS 和 IPS 前面加上K, M, G, T。但是需要注意的是，此处的K, M, G, T是数量单位。**K = Kilo = 千 = 10^3^，M = Million = 百万 = 10^6^，G = Giga = 十亿 = 10^9^，T = Tera = 万亿 = 10^12^ ，P = Peta = 千万亿 = 10^15^ ，E = Exa = 百京 = 10^18^ .**

#### 系统整体的性能指标

数据通路带宽：数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）。

吞吐量：指系统在单位时间内处理请求的数量。它取决于信息能多快地从内存送给一台外部设备。这些步骤中的每一步都关系到主存，因此，系统的吞吐量取决于主存的存储周期。

相应时间：指从用户向计算机发送一个请求，到系统对该请求做出响应并获得它所需要的结果的等待时间。通常包括CPU时间（运行一个程序花费的时间）与等待时间（用于磁盘访问、存储器访问、I / O操作、操作系统开销等时间）。

基准程序：用来测量计算机处理速度的一个实用程序，以便于被测量的计算机性能可以于运行相同的其它计算机性能进行比较。

#### 总结

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240621161432393.png" alt="image-20240621161432393" style="zoom:63%;" />



## 二、数据的表示与运算

### 2.1.1 进位计数制

#### r 进制计数法

r 进制：K~n~ K~n-1~ … K~2~ K~1~ K~0~ K~-1~ K~-2~ … K~-m~  =  K~n~ * r ^n^ + K~n-1~ * r ^n-1^ +  …  + K~2~ * r ^2^ + K~1~ * r ^1^ + K~0~ * r ^0^ + K~-1~ * r ^-1^ + K~-2~ * r ^-2^  + …  +   K~-m~  * r ^-m^。

基数：每个数码位所用到的不同符号的个数，r 进制的基数为 r 。

二进制：0，1。

八进制：0，1，2，3，4，5，6，7。

十六进制：0，1，2，3，4，5，6，7，8，9，A，B，C，D，E，F。

二进制可以使用两个稳定状态的物理器件表示。0，1正好对应逻辑值 假，真。方便实现逻辑运算。可以很方便的使用逻辑门电路实现算术运算。

#### 进制转换

二进制 —> 八进制：三位一组，每组转换成对应的八进制符号。八进制 —> 二进制的思路也类似，只需要将一位八进制数转换为三位二进制数即可。

二进制 —> 十六进制：四位一组，每组转换成对应的十六进制符号。十六进制 —> 二进制的思路也类似，只需要将一位十六进制数转换为三位二进制数即可。

**十进制 —> 任意进制：**

整数部分（除基取余法）：例如：十进制数 75 转换为二进制数为 (1001011)~2~ 。

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240622112843692.png" alt="image-20240622112843692" style="zoom:67%;" />

小数部分（乘基取整法）：例如：十进制小数 0.3 转换为二进制小数为 (010…)~2~ 。

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240622113141886.png" alt="image-20240622113141886" style="zoom:67%;" />

#### 各种进制的常见书写方式

二进制：(0010)**~2~**        0010**B**

八进制：(1653)**~8~**

十六进制：(92A)**~16~**       92A**H**       **0x**92A

#### 真值和机器数

真值：符合人类习惯的数字。

机器数：数字实际存储到机器里的形式，正负号均需要被 “ 数字化 ” 。

#### 总结

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240622113439079.png" alt="image-20240622113439079" style="zoom: 43%;" />



### 2.1.2 BCD码

快速转换，一一对应。

四个二进制位 —> 16种不同的状态。

BCD 码直接使用其中十种 —> 不同的解决方案。

#### 8421码的映射关系：

|  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 |

对于两个 8421 码的数，如果结果出现在了 1010 ~ 10010 这个区间内，那么我们就需要将这个结果加上 6 （ 即 (0110)~2~ ） ，这样才可以得到正确的 8421 码。

#### 余3码：

在 8421 码的基础上再加上 3 （ 即 (0011)~2~ ）。

|  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 | 1010 | 1011 | 1100 |

#### 2421码：

改变权值的定义。2，4，2，1 分别对应每一位的权值。

|  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 0000 | 0001 | 0010 | 0011 | 0100 | 1011 | 1100 | 1101 | 1110 | 1111 |

注意：0 ~ 4 的第一位一定是 0 ，5 ~ 9 的第一位一定是 1 。

#### 总结

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240622115302214.png" alt="image-20240622115302214" style="zoom:43%;" />



### 2.1.3 无符号整数的表示与运算

#### 无符号整数的表示

无符号整数，即 “ 自然数 ” ，0、1、2、3、4…

**机器字长的位数代表最多能同时进行多少位的运算**，现在的个人计算机机器字长一般为 64 位或 32 位。

无符号整数：

1. 全部二进制位都是数值位，没有符号位，第 i 位的位权是 2 ^i-1^ 
2. n bit 无符号整数表示范围 0 ~ 2 ^n^ - 1，超出则**溢出**，意味着该计算机无法一次处理这么多
3. 可以表示的最小的数 全 0 ，可以表示的最大的数 全 1 。

#### 无符号整数的运算

计算机硬件如何做无符号整数的加法：从最低位开始，按位相加，并往更高位进位。

计算机硬件如何做无符号整数的减法：

1.  “ 被减数 ” 不变， **“ 减数 ” 全部按位取反，末位加 1** ，减法变成加法。
2. 从最低位开始，按位相加，并往更高位进位。



### 2.1.4 带符号整数的表示和运算（原 / 反 / 补）

带符号整数，即 “ 整数 ” ，如 -2、-1、0、1、2、3、4…

#### 原码表示

| 符号位 | 2^6^ | 2^5^ | 2^4^ | 2^3^ | 2^2^ | 2^1^ | 2^0^ |
| :----: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |

原码：

1. 符号位 “ 0 / 1 ” 对应 “ 正 / 负 ” ，剩余数值位表示真值的绝对值。
2. 若机器字长位 n + 1 ，带符号整数的原码表示范围：- ( 2^n^ - 1 ) <= x <= 2^n^ - 1
3. 真值 0 有两种形式：+ 0 和 - 0 ，[ + 0 ]~原~ = 0,0000000 ; [ - 0 ]~原~ = 1,0000000 

原码的缺点：符号位不能参加运算，需要设计复杂的硬件电路才能处理。

用补码表示真值 —— 符号位可以参与运算。补码更便于计算机进行运算。

#### 原码 —> 反码 —> 补码 的转换

正数：原码，反码，补码均**不变**。

负数：原码 <—> 反码：**符号位不变，数值位取反**。反码 —> 补码：**末位加一** 。

**手算技巧：原码 <—> 补码：从右往左找到第一个 1 ，这个 1 的左边的所有的数值位全部按位取反。**

**补码的数值位不能解读为 “ 位权 ” 。**

#### 补码的运算

计算机如何做补码的加法：从最低位开始，按位相加（符号位参与运算），并往更高位进位。

计算机如何做带符号数补码的减法： [ A ]~补~ - [ B ]~补~ = [ A ]~补~ + [ -B ]~补~

1. “ 被减数 ” 不变， “ 减数 ” **全部按位取反，末位加一**，减法变加法。
2. 从最低位开始，按位相加，并往更高位进位。

注意：这里和转换为补码有所区别，带符号整数转换为补码的过程是**符号位不变，数值位取反，末位加一**，而做减法的过程是**全部按位取反，末位加一**。

#### 总结

tips：在计算机内部，所有带符号整数的加减法都要先转化为补码。

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240622125337379.png" alt="image-20240622125337379" style="zoom:50%;" />



### 2.1.5 原 / 反 / 补码 特性对比

#### 各种码的基本特性总结：

|     n+1 bit      |          合法表示范围          |       最大的数        |         最小的数          |                     真值0的表示                      |
| :--------------: | :----------------------------: | :-------------------: | :-----------------------: | :--------------------------------------------------: |
| 带符号整数：原码 | - ( 2^n^ - 1) <= x <= 2^n^ - 1 | 0,111…111 = 2^n^ - 1  | 1,111…111 = - ( 2^n^ - 1) | [ +0 ]~原~ = 0,000…000      [ - 0 ]~原~  = 1,000…000 |
| 带符号整数：反码 | - ( 2^n^ - 1) <= x <= 2^n^ - 1 | 0,111…111 = 2^n^ - 1  | 1,000…000 = - ( 2^n^ - 1) | [ +0 ]~反~ = 0,000…000      [ - 0 ]~反~  = 1,111…111 |
| 带符号整数：补码 |    - 2^n^ <= x <= 2^n^ - 1     | 0,111…111 = 2^n^ - 1  |    1,000…000 = - 2^n^     |   [ +0 ]~补~ = 0,000…000      真值 0 只有一种补码    |
|    无符号整数    |      0 <= x <= 2^n+1^ - 1      | 1111…111 = 2^n+1^ - 1 |       0000…000 = 0        |                       0000…000                       |

原码和反码的合法表示范围完全相同，都有两种方式表示真值 0 。

补码的合法表示范围比原码多一个负数，只有一种方式表示真值 0 。



### 2.1.6 移码

移码：补码的基础上将符号位取反，**注意：移码只能用于表示整数。**

若机器字长为 n+1 位，移码整数的表示范围： **- 2^n^ <= x <= 2^n^ - 1（与补码相同）**。

移码表示的整数很方便用硬件电路对比大小。



### 2.1.7 定点小数的表示和运算

定点整数的编码表示：原、反、补、移。

定点小数的编码表示：原、反、补。

定点小数的原反补码的转换方式与定点整数的**转换方式完全一样**，运算方式也是一样，这里就不多赘述了。

#### 定点小数各种码的基本特性总结：

|    n+1 bit     |           合法表示范围            |        最大的数         |          最小的数           |                     真值0的表示                      |
| :------------: | :-------------------------------: | :---------------------: | :-------------------------: | :--------------------------------------------------: |
| 定点小数：原码 | - ( 1 - 2^-n^ ) <= x <= 1 - 2^-n^ | 0,111…111 =   1 - 2^-n^ | 1,111…111 = - ( 1 - 2^-n^） | [ +0 ]~原~ = 0,000…000      [ - 0 ]~原~  = 1,000…000 |
| 定点小数：反码 | - ( 1 - 2^-n^ ) <= x <= 1 - 2^-n^ | 0,111…111 =   1 - 2^-n^ | 1,000…000 = - ( 1 - 2^-n^)  | [ +0 ]~反~ = 0,000…000     [ - 0 ]~反~  = 1,111…111  |
| 定点小数：补码 |       -1 <= x <= 1 - 2^-n^        | 0,111…111 =   1 - 2^-n^ |       1,000…000 = -1        |    [ +0 ]~补~ = 0,000…000     真值 0 只有一种补码    |

#### 定点小数与定点整数的区别

特别注意：位数扩展时，**扩展位置不一样**，定点小数的扩展位置位于末位，定点整数的扩展位置位于数值位之前，符号位之后。



### 2.2.0 奇偶校验码

奇校验码：整个校验码（有效信息位和校验位）中 “ 1 ” 的个数为奇数。

偶校验码：整个校验码（有效信息位和校验位）中 “ 1 ” 的个数位偶数。

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240622132807926.png" alt="image-20240622132807926" style="zoom:80%;" />

偶校验的硬件实现：各信息进行异或（模2加）运算，得到的结果即为偶校验位。



### 2.2.1 电路基本原理、加法器设计

#### 算术逻辑单元（ALU）

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240622135605865.png" alt="image-20240622135605865" style="zoom:75%;" />

算术运算：加、减、乘、除，逻辑运算：与、或、非、异或，辅助功能：移位、求补。

#### 最基本的逻辑运算

![image-20240622140239601](C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240622140239601.png)

​                                                                  与门                                     或门                                              非门

优先级：非运算  >  与运算  >  或运算。

#### 复合逻辑

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240622140444552.png" alt="image-20240622140444552" style="zoom:120%;" />

​                                                      与非                                                  或非                                                 异或

#### 一位全加器

输入：$A_{i} $ ；$B_{i} $ ；$C_{i-1} $ (来自低位的进位)

输出：$S_{i} $ (本位的和)：输入中有奇数个 1 时为 1 。（异或运算）
$$
S_{i} = A_{i}\oplus B_{i}\oplus C_{i-1}
$$
$C_{i} $ (向高位的进位)：$A_{i} B_{i}$ 计算的是两个本位均为 1 的情况，$\left(A_{i} \oplus B_{i}\right) C_{i-1}$ 计算的是两个本位中有一个 1 且来自低位的进位是 1 的情况。
$$
C_{i}=A_{i} B_{i}+\left(A_{i} \oplus B_{i}\right) C_{i-1}
$$
<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240622141855130.png" alt="image-20240622141855130" style="zoom:40%;" />

一位全加器的示意图：

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240622141954004.png" alt="image-20240622141954004" style="zoom:45%;" />

#### 串行加法器

串行加法器：只有一个全加器，数据逐位串行送入加法器中进行运算。进位触发器用来寄存进位信号，以便参与下一次运算。

如果操作数长 n 位，加法就要分 n 次进行，每次产生一位和，而且串行逐位地送回寄存器。

![image-20240622142356737](C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240622142356737.png)

#### 并行加法器

串行进位的并行加法器：把 n 个全加器串接起来，就可以进行两个 n 位数的相加。

串行进位又称为行波进位，每一级进位直接依赖于前一级的进位，即进位信号是逐级形成的。

![image-20240622142704040](C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240622142704040.png)

#### 总结

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240622142853268.png" alt="image-20240622142853268" style="zoom:40%;" />



### 2.2.2 并行进位加法器

#### 并行加法器的优化

第 i 位向更高位的进位 $C_{i} $ 可根据 被加数、加数的第 1 ~ i 位，再结合 $C_{0} $ 即可确定。
$$
\begin{array}{l}
G_{i}=A_{i} B_{i} \quad P_{i}=A_{i} \oplus B_{i} \\
C_{i}=A_{i} B_{i}+\left(A_{i} \oplus B_{i}\right) C_{i-1}=G_{i}+P_{i} C_{i-1}
\end{array}
$$
并级进位的并行加法器：各级进位信号同时形成，又称位先行进位、同时进位。

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240622143925165.png" alt="image-20240622143925165" style="zoom:60%;" />

由于继续套娃会导致电路越来越复杂，因此我们一般就只支持四位数据进行运算。示意图如下所示：

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240622144210830.png" alt="image-20240622144210830" style="zoom: 67%;" />



### 2.2.3 补码加减运算器

#### 回顾（补码加减运算方法）

n bit 补码 X + Y：按位相加即可。

n bit 补码 X - Y ：将补码 Y 全部按位取反，末位加 1 ，得到 [ - Y ]~补~ ，减法变成加法。

#### 补码加减运算器

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240622144912280.png" alt="image-20240622144912280" style="zoom:40%;" />

此外，无符号整数的加减法也可以用这个电路实现。



### 2.2.4.1 加减运算和溢出判断

#### 原码的加减运算

##### 加法

正 + 正  —>  绝对值做加法，结果为正。

负 + 负  —>  绝对值做加法，结果为负。

正 + 负 或 负 + 正 —>  绝对值大的减去绝对值小的，符号同绝对值大的数。

##### 减法

原码的减法运算， “ 减数 ” 符号取反，转变为加法，然后按照上面的思路运算即可。

#### 补码的加减运算

对于补码来说，无论加法还是减法，最后都会转变成加法，由加法器实现运算，符号位也参与运算。

#### 溢出判断

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240622145835827.png" alt="image-20240622145835827" style="zoom:67%;" />

只有 “ 正数 + 正数 ” 才会上溢。正 + 正 = 负。

只有 “ 负数 + 负数 ” 才会下溢。负 + 负 = 正。

##### 方法一：采用一位符号位

设 A 的符号为 A~S~ ，B 的符号为 B~S~ ，运算结果的符号为 S~S~ ，则溢出逻辑表达式为：
$$
V = A_{S}B_{S}\overline{S_{S}} + \overline{A_{S}}\overline{B_{S}}S_{S}
$$
若 V = 0 ，则表示无溢出。若 V = 1 ，则表示有溢出。

##### 方法二：采用一位符号位，根据数据位进位情况判断溢出。

|      | 符号位的进位 C~S~ | 最高数值位的进位C~1~ |
| :--: | :---------------: | :------------------: |
| 上溢 |         0         |          1           |
| 下溢 |         1         |          0           |

即 C~S~ 与 C~1~ 不同的时候说明产生了溢出。

溢出逻辑判断表达式：$V=C_{S} \oplus C_{1}$ ，若 V = 0 ，则表示无溢出，若 V = 1，表示产生了溢出。

##### 方法三：采用双符号位

正数符号为 00 ，负数符号为 11 。

记两个符号位为 S~S1~S~S2~ ，则 $V=S_{S1} \oplus S_{S2}$ 。若 V = 0 ，表示无溢出，若 V = 1，表示有溢出。

双符号位补码又称为模4补码，单符号位补码又称为模2补码。

实际存储时只存储一个符号位，运算时会复制一个符号位。

#### 符号扩展

定点整数的符号扩展：在原符号位和数值位中间添加新位，正数都添加 0 ，负数原码添加 0 ，反码和补码添加 1 。

定点小数的符号扩展：在原符号位和数值位后面添加新位，正数都添加 0 ，负数原、补码添加 0 ，负数反码添加 1 。

#### 总结

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240622152059293.png" alt="image-20240622152059293" style="zoom:45%;" />



### 2.2.4.2 标志位的生成

#### OF (Overflow Flag) 

溢出标志：溢出时为 1 ，否则置为 0 。

含义：有符号数的加减运算是否发生了溢出。OF = 1 时，说明发生了溢出。

硬件计算方法：$ OF = 最高位产生的进位 \oplus 次高位产生的进位$ 。 

注意：OF位对于无符号数的加减无意义。

#### SF (Sign Flag) 

符号标志：结果为负时为 1 ，结果为正时为 0 。

含义：有符号数加减运算结果的正负性，SF = 0 时表示运算结果为正数，SF = 1 时表示运算结果为负数。

硬件计算方法：SF = 最高位的本位和。

注意：SF位对于无符号数的加减无意义。

#### ZF (Zero Flag)

零标志：运算结果为 0 时 ZF 位置 1 ，否则置为 0 。

含义：表示运算结果是否为 0 ，ZF = 1 时表示结果为 0 ，ZF = 0 表示结果非 0 。

硬件计算方法：两个数的运算结果为 n bit，只有 n bit 全为 0 时，ZF = 1 。

#### CF (Carry Flag)

进位 / 借位标志，进位 / 借位 时置为 1 ，否则置为 0 。

含义：表示无符号数的加减法是否发生了进位或借位。当 CF = 1 时，说明无符号数的加减运算发生了进位或借位，也即发生了溢出。

硬件计算方法：$ CF = 最高位产生的进位 \oplus sub$ 。sub 为 1 表示减法，sub 为 0 表示减法。

注意：CF 位对于有符号数的加减法无意义。



### 2.2.5 定点数的移位运算

#### 算术移位

移位：通过改变各个数码位和小数点的相对位置，从而改变各数码位的位权。可用移位运算实现乘法、除法。

#### 原码的算术移位 

 符号位保持不变，仅对数值位进行移位。

右移：**高位补 0** ，低位舍弃，若舍弃的位等于 0 ，则相当于 “ / 2 ” ，若舍弃的位不等于 0 ，则会**丢失精度**。

左移：**低位补 0** ，高位舍弃，若舍弃的位等于 0 ，则相当于 “ * 2 ” ，若舍弃的位不等于 0 ，则会**出现严重误差**。

#### 反码的算术移位

正数的反码和原码相同，因此**对正数反码的移位运算也和原码相同**。

负数的反码数值位和原码相反，因此负数反码的移位运算规则如下：

右移：高位补 1 ，低位舍弃。

左移：低位补 1 ，高位舍弃。

#### 补码的算术移位

由于正数的补码和原码也是一样的，因此**对正数补码的移位运算也和原码相同**。

负数补码 = 反码末位 + 1 ，导致反码最右边的几个连续的 1 都因为进位而变为 0 ，直到碰到第一个 0 为止。

**规律： 负数补码中，最右边的 1 及其右边同原码，最右边的 1 的左边同反码。**

**右移（同反码）：高位补 1 ，低位舍弃。**

**左移（同原码）：低位补 0 ，高位舍弃。**

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240622155243991.png" alt="image-20240622155243991" style="zoom:50%;" />

#### 逻辑移位

逻辑右移：高位补 0 ，低位舍弃。

逻辑左移：低位补 0 ，高位舍弃。

可以把逻辑移位看作是对 “ 无符号数 ” 的算术移位。

#### 总结

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240622155643673.png" alt="image-20240622155643673" style="zoom:45%;" />



### 2.2.6.1 原码的乘法运算

#### 例题

设机器字长为 n + 1 = 5 位（含 1 位符号位），[ x ]~原~ = 1.1101，[ y ]~原~ = 0.1011，采用原码一位乘法求出 x * y。

#### 求解思路

- 符号单独处理：$ 符号位 = x_{s} \oplus y_{s}$​ 
- 数值位取绝对值进行乘法计算

#### 实现方法

先加法再移位，重复 n 次。每次加法可能 **+ 0 、 + [ | x | ]~原~** 。需要根据 MQ 的最低位来判断需要加什么。

每次移位是 **“ 逻辑右移 ”**

**符号位不参与运算** 

- 若当前 MQ 中**最低位 = 1** ，则 **(ACC) + [ | x | ]~原~** 
- 若当前 MQ 中**最低位 = 0** ，则 **(ACC) + 0** 

#### 运算器构造示意图

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240623115301941.png" alt="image-20240623115301941" style="zoom:40%;" />

#### 具体步骤

再正式进行乘法之前，ACC置为 0 。运算过程中，被乘数被置于 X 中，内容一直为 01101 ，MQ 中的内容会随着计算和移位发生变化。注意，MQ 的被涂成灰色的那位是**当前进行乘法的位**。当前位 = 1，则 ACC 需要加上被乘数，当前位 = 0 ，则 ACC 加上 0 。

- 第一步：由于乘数为 01011，第一步计算进行的时候当前位为 1 ，应执行 (ACC) + (X) —> ACC ，此时，ACC 中的内容为 00000，X 中的内容为 01101 ，ALU 计算完之后的结果为 01101 ，然后这个结果会被传递到 ACC中。接下来，ACC 和 MQ 中的数据需要总体向右移动一位，然后最高位补 0 ，最低位舍弃，移位之后 ACC 中的内容为 **00110** ，MQ 的内容为 **1**0101。
- 第二步：之后计算乘数的次低位，由于 MQ 中的内容为 10101 ，当前位为 1 ，同样要执行 (ACC) + (X) —> ACC ，此时 ACC 的内容为 00110 ，X 中的内容为 01101 ，ALU 计算得到的结果为 10011 ，因此 ACC 的结果被更新为 10011，然后 ACC 和 MQ 中的数据总体右移一位，高位补 0 ，得到的结果为：ACC 中的内容是 **01001** ，MQ 中的结果为 **11**010 。
- 第三步：接下来由于 MQ 中的内容为 11010 ，当前位为 0 ，因此要执行 (ACC) + 0 —> ACC，结果依然是 01001 ，右移之后得到：ACC 的内容为 **00100** ，MQ 的内容为 **111**01。
- 第四步：再之后，MQ 中的内容为 11101，当前位为 1 ，因此再次执行 (ACC) + (X) —> ACC ，ACC 中的内容为 00100 ，X中的内容为 01101，ALU计算得到的结果为 10001，右移之后得到的结果为：ACC 中的内容为 **01000** ，MQ 中的内容为 **1111**0 。
- 第五步：此时，MQ 中的内容为 11110，当前位为 0 ，但是此时当前位是乘数的符号位，符号位不参与运算，因此，我们就可以得到最终计算结果：**0.10001111** 。
- 第六步：上述步骤只是得到了绝对值的乘积，我们还需要计算符号位，由于被乘数的符号位为 1 ，乘数的符号位为 0，因此符号位的结果为 1 。最终的计算结果为：**1.10001111** 。

#### 手算模拟

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240623122413612.png" alt="image-20240623122413612" style="zoom:35%;" />

注意：这里使用单符号位和双符号位均可以，不过由于补码的乘法需要使用双符号位，因此为了统一这里就采用了双符号位。

#### tips

1. 乘数的符号位不参与运算，可以省略。
2. 原码一位乘法可以只用单符号位。
3. 答题时最终结果最好写为原码机器数。



### 2.2.6.2 补码的乘法运算

#### 例题

设机器字长为 5 位（含 1 位符号位， n = 4），x = - 0.1101，y = + 0.1011 ，采用补码一位乘法来计算 x * y 。

#### 实现方法

**进行 n 轮加法、移位，最后再多来一次加法**，每次加法可能 **+ 0 、+ [ x ]~补~ 、+ [ - x ]~补~** 。这里需要根据当前 MQ 的**最低位、辅助位**来确定加什么。

每次移位时 **“ 补码的算术右移 ”** ：符号位不动，数值位右移，正数右移补 0 ，负数右移补 1 （**符号位是啥就补啥**）。

**符号位参与运算**

- **辅助位 - MQ 中最低位 = 1 时，(ACC) +  [ x ]~补~ **
- **辅助位 - MQ 中最低位 = 0 时，(ACC) +  0 **
- **辅助位 - MQ 中最低位 = -1 时，(ACC) +  [ - x ]~补~ **

#### 运算器构造示意图

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240623124629336.png" alt="image-20240623124629336" style="zoom:96%;" />

#### 手算模拟

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240623124736024.png" alt="image-20240623124736024" style="zoom:90%;" />



### 2.2.7.1 原码的除法运算 

#### 例题

设机器字长为 5 位（含一位符号位，n = 4），x = 0.1011，y = 0.1101，求 x / y 。

#### 规律

忽略小数点，每确定一位商，进行一次减法，得到 4 位余数，再余数末尾补 0 ，再确定下一位商。确定 5 位商即可停止（机器字长为 5 位）。

#### 求解思路

- 上商 0 / 1，得到余数，余数末尾补 0 
- 符号单独处理：$ 符号位 = x_{s} \oplus y_{s}$​ 
- 数值位取绝对值进行乘法计算

#### 运算器示意图

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240623131742425.png" alt="image-20240623131742425" style="zoom:45%;" />

#### 恢复余数法

准备： | x | = 0.1011 ；| y | = 0.1101 ；[ | y | ]~补~ = 0.1101 ；[ - | y | ]~补~ = 1.0011 。再正式进行除法之前，MQ 置为 0 。运算过程中，被乘数和余数被置于 ACC 中，内容会随着计算和移位发生变化。除数被置于 X 中，内容一直为 01101 ，注意，MQ 的被涂成灰色的那位是**当前需要确定的一位商**。计算机会默认线上商 1 ，如果错了的话再改上商 0 。并 “ 恢复余数 ” 。

- 第一步：MQ 的最低位先上商 1 ，然后执行 (ACC) - (除数) —> ACC，即计算 (ACC) + [ - | y | ]~补~ —> ACC ，由于此时 ACC 的内容为 01011 ，[ - | y | ]~补~ = 10011（忽略小数点），ALU 计算的结果为 **11110** ，然后这个结果被传递给 ACC。但是此时的相减结果是一个负数，说明应该上商 0 。因此 MQ 的最低位被修改为 0，此时会执行 (ACC) + (除数) —> ACC ，即计算(ACC) + [ | y | ]~补~ —> ACC ，这样就恢复成了之前的余数 01011，然后这个余数又被传递给 ACC。接下来 ACC 和 MQ 中的内容需要整体左移一位，得到新的结果：ACC的内容为 **10110** ，MQ 的内容为 000**0**0 。
- 第二步：MQ 的最低位先上商 1，即计算 (ACC) + [ - | y | ]~补~ —> ACC （ 10110 + 10011 = 01001 ），得到的结果为 01001，此时的结果是一个正数，说明商 1 是正确的，因此 MQ 中的内容为 000**01** 。然后就让 ACC 和 MQ 中的内容需要整体左移 ，得到：ACC 的内容为 **10010** ，MQ 的内容为 00**01**0 。
- 第三步：继续重复之前的步骤，先上商 1 ，即计算 (ACC) + [ - | y | ]~补~ —> ACC （ 10010 + 10011 = 00101 ），此时的结果也是一个正数，说明商 1 同样是正确的，MQ 中的内容为 00**011** 。再让 ACC 和 MQ 中的内容需要整体左移 ，得到：ACC 的内容为 **01010** ，MQ 的内容为 0**011**0 。
- 第四步：重复之前步骤，上商 1 ，即计算 (ACC) + [ - | y | ]~补~ —> ACC （ 01010 + 10011 = 11101 ），此时结果是一个负值，因此需要上商 0 并恢复余数，因此需要计算 (ACC) + [ | y | ]~补~ —> ACC （11101 + 01101 = 01010 ），此时 MQ 中的内容为 0**0110** 。然后让 ACC 和 MQ 中的内容需要整体左移 ，得到：ACC 的内容为 **10100** ，MQ 的内容为 **0110**0 。
- 第五步：先上商 1 ，即算 (ACC) + [ - | y | ]~补~ —> ACC （ 10100 + 10011 = 00111），结果为正，因此商 1 是正确的，此时 MQ 的内容为 **01101** ，由于机器字长为 5 位，我们只能求出 5 位的商，故最终的结果就是 01101 。
- 注意：**若最后一步商余数是负数，那么我们还是需要恢复余数并商 0** 。
- 最后我们再来处理符号和小数点，由于 x 和 y 均为正数，因此结果也是正数。最终结果位 0.1101

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240623135949571.png" alt="image-20240623135949571" style="zoom:40%;" />

#### 加减交替法

我们把是负数的余数记为 a ，[ | y | ]~补~ 记为 b ，由于在余数为负数时我们需要进行 a + b 的操作恢复余数，然后将结果左移，左移会使结果 * 2，即 （a + b）* 2 ，然后我们又会重新上商 1 ，即 （a + b）* 2 - b ，结果即为 2 * a + b ，要得到这个结果，我们也可以在得到负数余数 a 的时候将结果左移，即 a * 2 ，然后再加上除数的绝对值 b ，这样也可以实现相同的效果。

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240623141357126.png" alt="image-20240623141357126" style="zoom:80%;" />

**若余数为负，则可直接商 0 ，让余数左移 1 位再加上 | 除数 | ，得到下一个新余数。**

若余数为正，则商 1 ，让余数左移 1 位再减去  | 除数 | ，得到下一个新余数。

注意：如果最后一步的**余数为负数的话，使用加减交替法也需要恢复余数**，这样才能得到正确的余数和结果。

加减交替法需要 加 / 减 n + 1 次，每次加减确定一位商，左移 n 次（最后一次加减完不移位），最终可能还要再多一次加法运算（恢复余数）。因此最多需要进行加减 n + 2 次。



### 2.2.7.2 补码的除法运算

#### 补码除法

- 符号位参与运算
- 被除数 / 余数、除数均采用双符号位

#### 例题

设机器字长为 5 位（含 1 位符号位，n = 4），x = + 0.1000，y = - 0.1011，采用补码加减交替除法求 x / y

#### 求解思路

- 被除数与除数**同号，则被除数减去除数，异号，则被除数加上除数。**
- 除数和余数**同号，商 1 ，余数左移一位减去除数；**
- 除数和余数**同号，商 0 ，余数左移一位加上除数。**
- **末位恒置为 1** 。（精度误差不超过 2 ^-n^）

以上步骤重复 n 次。

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240623143224148.png" alt="image-20240623143224148" style="zoom:85%;" />

#### 总结回顾

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240623143426532.png" alt="image-20240623143426532" style="zoom:80%;" />



### 2.2.8 C语言类型转换

C语言中的定点整数时用 “ 补码 ” 存储的。

无符号数与有符号数：不改变数据内容，改变解释方式。

长整数变短整数：高位截断，低位保留。

短整数变长整数：符号扩展。



### 2.2.9 数据的存储与排列

#### 大小端模式

多字节数据再内存里一定是占连续的几个字节的。

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240623144120340.png" alt="image-20240623144120340" style="zoom:80%;" />

大端方式更便于人类阅读，而小段方式更便于机器处理。

#### 边界对齐

现代计算机通常是按照字节编址，即每个字节对应一个地址

通常也支持按字、半字、按字节寻址

假设存储字长为 32 位，则一个字 = 32 bit ，半字 = 16 bit。每次访存只能读写 1 个字。

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240623144501457.png" alt="image-20240623144501457" style="zoom:80%;" />



### 2.3.1 浮点数的表示

#### 浮点数的表示

定点数可表示的数字范围有限，但是我们不能无限制地增加数据的长度。

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240623150132859.png" alt="image-20240623150132859" style="zoom:50%;" />

浮点数的真值： N = r ^E^  * M

阶码 E ：常用**补码或者移码**表示的定点整数。阶码反映浮点数的**表示范围**和小数点的**实际位置**。

尾数 M ：常用**原码或者补码**表示的定点小数。尾数的数值部分的位数 n 反映**浮点数的精度**。

#### 规格化浮点数

规定尾数的最高数值位必须时一个有效值。

左规：当浮点数运算的结果为非规格化时要进行规格化处理，将**尾数算数左移 1 位，阶码减 1 ，直到尾数最高位是有效值。**

右规：当浮点数运算的结果尾数出现溢出（双符号位为 01 或 10）时，**将尾数算术右移 1 位，阶码加 1** 。

注：采用 “ 双符号位 ” ，当溢出发生时，可以挽救。更高的符号位是正确的符号位。

#### 规格化浮点数的特点

1. 用原码表示的尾数进行规格化：

   正数为 0.1xxx 的形式，最大值表示为 0.111…1 ，最小值表示为 0.100…0 

   尾数的表示范围为 1 / 2 <=  M  <= ( 1 - 2 ^-n^ )

   负数为 1.1xxx 的形式，最大值表示为 1.10…0，最小值表示为 1.11…1

   尾数的表示范围为 -( 1 - 2 ^-n^ ) <=  M  <=  -1 / 2

2. 用补码表示的尾数进行规格化：

   正数为 0.1xxx 的形式，最大值表示为 0.111…1 ，最小值表示为 0.100…0 

   尾数的表示范围为 1 / 2 <=  M  <= ( 1 - 2 ^-n^ )

   负数为 1.0xxx 的形式，最大值表示为 1.01…1 ，最小值表示为 1.00…0

   尾数的表示范围为 -1 <=  M  <=  -( 1/2 + 2 ^-n^ )

   ![image-20240623152718614](C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240623152718614.png)

#### 总结

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240623152922478.png" alt="image-20240623152922478" style="zoom:35%;" />



### 2.3.2 浮点数标准 IEEE 754

#### 移码

移码：补码的基础上将符号位取反。注意：移码只能用于表示整数。

移码的定义：移码 = 真值 + 偏置值

8 位移码的偏置值 = 128 D = 1000 0000 B ，即 2 ^n-1^

偏置值一般取 2 ^n-1^ ，此时 移码 = 补码符号位取反，偏置值也可以取其它值。这里我们令偏置值 = 127 D = 0111 1111 B ，即            2 ^n-1^ - 1

#### IEEE 754标准

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240623163450259.png" alt="image-20240623163450259" style="zoom:80%;" />

阶码真值 = 移码 - 偏移量

最小绝对值：尾数全为 0 ，阶码真值最小 -126，对应移码机器数 0000 0001 ，此时整体的真值为 (1.0)~2~ * 2 ^-126^

最大绝对值：尾数全为 1 ，阶码真值最大 127 ，对应移码机器数 1111 1110 ，此时整体的真值位 (1.111…1)~2~ * 2 ^127^

##### 阶码全 1、全 0 用作特殊用途

当阶码 E 全为 0 ，尾数 M 不全为 0 时，表示非规格化小数  $ \pm $ (0.xxx…x)~2~ * 2 ^-126^ ，隐含最高位变为 0 ，阶码真值固定视为 -126

当阶码 E 全为 0 ，尾数 M 全为 0 时，表示真值  $\pm0$

当阶码 E 全为 1 ，尾数 M 全为 0 时，表示无穷大 **$\pm \infty $**

当阶码 E 全为 1 ，尾数 M 不全为 0 时，表示非数值 **“ NaN ”**（非法运算的结果就是 “ NaN ”）



### 2.3.3 浮点数的运算

#### 浮点数加减运算

步骤：9.85211 * 10 ^12^  +  9.96007 * 10 ^10^

1. 对阶： 9.85211 * 10 ^12^  +  0.0996007 * 10 ^12^ （小阶向大阶靠齐）

2. 尾数加减：9.9517107 * 10 ^12^

3. 规格化：如果尾数加减出现类似 0.0099517 * 10 ^12^ 时，需要 “ 左规 ” ，如果尾数加减出现类似 99.517107 * 10 ^12^ 时，需要 “ 右规 ” 。

4. 舍入：若规定只能保留 6 位有效尾数，则 9.9517107 * 10 ^12^ —> 9.95171  * 10 ^12^ （多余部分直接砍掉），或者采用四舍五入的原则，亦或者只要砍掉部分非 0 直接入 1 。

5. 判溢出：若规定阶码不能超过两位，则运算后阶码超出范围，则溢出。

   如：9.85211 * 10 ^99^  +  9.96007 * 10 ^99^ = 19.81218 * 10 ^99^ 。此时阶码会超出两位，发生溢出。（注：尾数溢出未必导致整体溢出，也许可以通过 3、4 两步骤来拯救）

#### 浮点数的舍入

- “ 0 ” 舍 “ 1 ” 入法：类似十进制中的 “ 四舍五入 ” 法，即在尾数右移时，被移去的最高数值位为 0 ，则舍去，被移去的最高数值位为 1 ，则在尾数的末位加 1 ，这样做可能会使尾数又溢出，此时需要再做一次 “ 右规 ” 。
- 恒置 “ 1 ” 法：尾数右移时，不论丢掉的最高数值位是 “ 1 ” 还是 “ 0 ” ，都使右移后的尾数末位恒置 “ 1 ” ，这种方法同样有使尾数变大和变小的两种可能。 

#### 强制类型转换

范围、精度由小到大，转换过程没有损失。

#### 总结

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240623172130501.png" alt="image-20240623172130501" style="zoom:35%;" />



## 三、存储系统

### 3.1 存储系统基本概念

#### 存储器的层次化结构

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240622162905265.png" alt="image-20240622162905265" style="zoom:40%;" />

越靠近上层，则访问速度越快，但是相应的容量也会越小，价格也会越高。

有些教材会把磁盘、U盘、光盘统称为 “ 辅存 ” 或 “ 外存 ” 。

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240622163055045.png" alt="image-20240622163055045" style="zoom:50%;" />

辅存中的数据要调入主存后才能被 CPU 访问。

主存和辅存之间的数据交换是通过硬件加上操作系统实现的，操作系统需要负责实现页面置换算法。主存和 Cache 之间的数据交换由硬件自动交换。

主存 - 辅存：实现虚拟存储系统，解决了主存容量不够的问题。

Cache - 主存：解决了主存与 CPU 速度不匹配的问题。

#### 存储器的分类 —— 层次

1. 高速缓存（Cache）
2. 主存储器（主存、内存）
3. 辅助存储器（辅存、外存）

前两个可直接被 CPU 读写。

#### 存储器的分类 —— 存储介质

1. 半导体存储器（主存、Cache），以半导体器件存储信息
2. 磁表面存储器（磁盘、磁带），以磁性材料存储信息。
3. 光存储器（光盘），以光介质存储信息。

#### 存储器的分类 —— 存取方式

1. 随机存取存储器（RAM）：读写任何一个存储单元所需时间都相同，与存储单元所在的物理位置无关。
2. 顺序存取存储器（ROM）：读写一个存储单元所需时间取决于存储单元所在的物理位置。
3. 直接存取存储器（DAM）：既有随机存取特性，也有顺序存取特性。先直接选取信息所在区域，然后按顺序方式存取。
4. 相联存储器，即可以按照内容访问的存储器（CAM）：可以按照内容检索到存储位置进行读写， “ 快表 ” 就是一种相联存储器。

2、3 两种存储器可以被归类为串行访问存储器，它们读取某个存储单元所需时间与存储单元的物理位置有关。

#### 存储器的分类 —— 信息的可更改性

1. 读写存储器：既可读，也可写。（磁盘、内存、Cache）。
2. 只读存储器：只能读。不能写。（如音乐专辑通常采用 CD - ROM ，实体电影采用蓝光光碟，BIOS 通常写在 ROM 中）

事实上，很多 ROM 也可以多次读写，只是比较麻烦。

#### 存储器的分类 —— 信息的可保存性

1. 断电后，存储信息消失的存储器 —— 易失性存储器（主存、Cache）
2. 断电后，存储信息依然保持的存储器 —— 非易失性存储器（磁盘、光盘）
3. 信息读出后，原存储信息被破坏 —— 破坏性读出（如DRAM芯片，读出数据后需要进行重写）
4. 信息读出后，原存储信息不被破坏 —— 非破坏性读出（如SRAM芯片，磁盘，光盘）

#### 存储器的性能指标

1. 存储容量：存储字长 * 字长（MDR位数反应存储字长）
2. 单位成本：每位价格 = 总成本 / 总容量
3. 存储速度：数据传输率 = 数据的宽度 / 存储周期（数据的宽度即存储字长）

存储周期又可以被划分为**存取时间**和**恢复时间**两个部分。

- 存取时间（T~a~）：存取时间是指从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间。
- 存取周期（T~m~）：存取周期又称为读写周期或访问周期。它是指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立的访问存储器的操作（读操作或写操作）之间所需的最小时间间隔。

主存带宽（B~m~）：主存带宽又称数据传输率，表示每秒从主存进出信息的最大数量，单位为 字 / 秒、字节 / 秒（B / s）或 位每秒 （b / s）。

#### 总结

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240622171019133.png" alt="image-20240622171019133" style="zoom:48%;" />



### 3.2 .1 主存储器的基本组成

#### 存储器芯片的基本原理

数据总线（宽度 = 存储字长）

总容量 = 存储单元个数 * 存储字长 = 2^3^ * 8 bit = 2^3^ * 1 Byte = 8 B

![image-20240622183704546](C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240622183704546.png)

片选线用于判断该芯片目前是否正在使用。

两根 读 / 写 线：WE 允许写，OE 允许读

一根 读 / 写 线：WE 低电平写，高电平读

![image-20240622183544703](C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240622183544703.png)

上图的每根线都会对应一个金属引脚（另外，通常还会有供电引脚，接地引脚）。

一般在译码器后面会加上一个驱动器，以保证译码器输出的电信号是稳定可靠的。

n 位地址 —> 2^n^ 个存储单元

8 * 8 位的存储芯片

常见的描述： 8k * 8位，即 2^13^ * 8 bit

​		       8k * 1位，即 2^13^ * 1 bit

​		       64k * 16位，即 2^16^ * 16 bit 

#### 寻址

假设一个存储芯片的字长为 4 B，总容量为 1 KB，即 256 字。则地址线有 10 根。

按字节寻址：1 K 个单元，每个单元 1 B。

按字寻址：256 个单元，每个单元 4 B。

按半字寻址：512 个单元，每个单元 2 B。

按双字寻址：128 个单元，每个单元 8 B。

#### 总结

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240622184759386.png" alt="image-20240622184759386" style="zoom:35%;" />



### 3.2.2 SRAM 和 DRAM

#### DRAM 芯片

DRAM 芯片：使用**栅极电容**存储信息。

SRAM 芯片：使用**双稳态触发器**存储信息。

核心：存储元不一样。

##### 栅极电容：

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240622190503548.png" alt="image-20240622190503548" style="zoom:100%;" />

读出 1 ：MOS 管接通，电容放电，数据线上产生电流。

读出 0 ：MOS 管接通后，数据线上无电流。

电容放电信息被破坏，是破坏性读出，读出后应有重写操作，也称 “ 再生 ” 。（读写速度更慢）

每个存储元制造成本更低，集成度高，功耗低。

##### 双稳态触发器：

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240622190709771.png" alt="image-20240622190709771" style="zoom:30%;" />

读出 1 ：A 高 B 低。

读出 0 ：A 低 B 高。

读出数据，触发器状态保持稳定，是非破坏性读出，无需重写。（读写速度更快）

每个存储元制造成本更高，集成度低，功耗大。

#### DRAM的刷新

刷新周期；一般为 2 ms 。

每次刷新的存储单元：以行为单位，每次刷新一行存储单元。

拆分为行列地址，从而减少选通线的数量。

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240622191906120.png" alt="image-20240622191906120" style="zoom:40%;" />

如何刷新：有硬件支持，读出一行信息后重新写入，占用 1 个读 / 写 周期。

什么时候刷新：假设 DRAM 内部结构排列成 128 * 128 的形式，读 / 写 周期为 0.5 us

​	2 ms 共 2 ms / 0.5 us = 4000 个周期。

- 思路1：每次读写完都刷新一行 —> 系统的存取周期变为 1 us，前 0.5 us 时间用于正常读写，后 0.5 us 的时间用于刷新某行。

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240622192532537.png" alt="image-20240622192532537" style="zoom:120%;" />

- 思路2：2 ms 内集中安排时间全部刷新 —> 系统的存取周期还是 0.5 us ，有一段时间专门用于刷新，无法访问存储器，称为访存 “ 死区 ” 。

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240622192800167.png" alt="image-20240622192800167" style="zoom:45%;" />

- 思路3：2 ms 内每行刷新 1 次即可 —> 2 ms 内需要产生 128 次刷新请求，每隔 2 ms / 128 = 15.6 us 一次，每 15.6 us 内有 0.5 us 的 “ 死时间 ” （可以在译码阶段刷新）。

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240622193136437.png" alt="image-20240622193136437" style="zoom:48%;" />

#### DRAM的地址线复用技术

行列地址分成两次送，从而使得地址线更少，芯片引脚更少。第一次先将行地址送到行地址缓冲器中，第二次将列地址送到列地址缓冲器中。

#### 总结

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240622191307589.png" alt="image-20240622191307589" style="zoom:35%;" />



### 3.2.3 只读存储器ROM

#### MROM（掩模式制度存储器）

厂家按照客户需求，在芯片生产过程中直接写入信息，之后**不允许任何人重写（只能读出）**。

优点：可靠性高、灵活性差、生产周期长、只适合批量定制。

#### PROM（可编程只读存储器）

用户可用专门的 PROM 写入器写入信息，但是**写一次之后就不可更改**。

#### EPROM（可擦除可编程只读存储器）

允许用户写入信息，之后通过某种方法擦除数据，可进行**多次重写**。

例如：UVRPROM —— 用紫外线照射 8 ~ 20 分钟，就可以擦除所有信息。

​	  EEPROM —— 可用 “ 电擦除 ” 的方式，擦除特定的字。

#### Flash Memory（闪速存储器）

U盘、SD卡就是闪存

在 EEPROM 基础上发展而来，断电后也能保存信息，且可**进行多次快速擦除重写**。

注意：由于闪存需要先擦除在写入，因此闪存的 “ 写 ” 速度要比 “ 读 ” 速度更慢。

#### SSD（固态硬盘）

由控制单元 + 存储单元（Flash芯片）构成，与闪速存储器的核心区别在于控制单元不一样，但是存储介质都类似，可进行**多次快速擦除重写**。SSD 速度快，功耗低，价格高。目前个人电脑上常用 SSD 取代传统的机械硬盘。

#### 计算机内的重要ROM

主板上的 BIOS 芯片（ROM），存储了 “ 自举装入程序 ” ，负责指导装入操作系统（开机）。

注：我们常说 “ 内存条 ” 就是 “ 主存 ” ，但是事实上，主板上的 ROM 芯片也是 “ 主存 ” 的一部分。

#### 总结

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240622195619157.png" alt="image-20240622195619157" style="zoom:75%;" />

- 很多 ROM 芯片虽然名字是 “ Read - Only ” ，但是**很多 ROM 也可以 “ 写 ”** 。
- **闪存的写速度一般比读速度更慢**，因为写入前要先擦除。
- RAM 芯片是易失性的，ROM 芯片是非易失性的。**很多 ROM 也具有 “ 随机存取 ” 的特性**。



### 3.2.4 双端口RAM和多模块存储器

#### 双端口RAM

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240623172519949.png" alt="image-20240623172519949" style="zoom:80%;" />

作用：优化多核 CPU 访问一根内存条的速度。

需要有立足完全独立的数据线、地址线、控制线。CPU、RAM中也要有更复杂的控制电路。

两个端口对同一主存操作有以下 4 种情况：

1. 两个端口同时对不同的地址单元存取数据
2. 两个端口同时对同一地址单元读出数据
3. 两个端口同时对同一地址单元写入数据 （写入错误）
4. 两个端口同时对同一地址单元，一个写入数据，另一个读出数据 （读出错误）

解决方法：置 “ 忙 ” 信号位 0 ，由判断逻辑决定暂时关闭一个端口，即被延时，未被关闭的端口正常访问，被关闭的端口延长一个很短的时间段后再访问。

#### 多体并行存储器

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240623173245552.png" alt="image-20240623173245552" style="zoom:40%;" />

可以理解为 “ 四根内存条 ”。每个模块都有相同的容量和存取速度。各模块都有独立的读写控制电路、地址寄存器和数据寄存器。它们既能并行工作，又能交叉工作。

假设每个存储体存取周期为 T ，存取时间为 r ，T = 4r。连续访问 00000 00001 00010 00011 00100 ，则：

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240623173919480.png" alt="image-20240623173919480" style="zoom:50%;" />

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240623174033159.png" alt="image-20240623174033159" style="zoom:50%;" />

因此，连续访问的情况下，低位交叉编址的效率比高位交叉编址的效率要高得多。

#### 应该取几个存储体

采用 **“ 流水线 ”** 的方式并行存取（宏观上并行，微观上串行）

宏观上，一个存储周期内，m 体交叉存储器可以提供的数据量为单个模块的 m 倍

存取周期为 T ，**存取时间为 r**（总线传输周期为 r） ，为了使流水线不间断，应保证模块数 m >= T / r

![image-20240623174708811](C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240623174708811.png)

#### 单体多字存储器

每个存储单元存储 m 个字，总线宽度也为 m 个字，一次并行读出 m 个字。

每次只能同时取 m 个字，不能单独取其中某个字。灵活性较差。

#### 总结

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240623175319458.png" alt="image-20240623175319458" style="zoom:33%;" />



### 3.3.1 主存储器与CPU的连接

#### 现代的计算机

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240623180401733.png" alt="image-20240623180401733" style="zoom:80%;" />

#### 存储芯片的输入输出信号

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240623180614443.png" alt="image-20240623180614443" style="zoom:80%;" />

注意：有横线代表低电平有效，没有横线代表高电平有效。

#### 增加主存的存储字长 —— 位扩展

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240623181104499.png" alt="image-20240623181104499" style="zoom:80%;" />

对于上面的 8 个存储芯片，它们的片选线（CS）相同，地址总线（A~0~ ~ A~12~）也相同，只是它们的数据总线是依次连接 D~0~ ~ D~7~。经过这样的操作之后，它们就组成了一个 8K * 8 位的存储器，这个存储器的容量位 8 KB 。

#### 增加主存的存储字数 —— 字扩展

线选法： n 条线 —> n 个片选信号。但是该方法的地址空间不连续，例如对于两条线的话，只有 01 和 10 是合理的，00 和 11 是无法使用的。

译码片选法：n 条线 —> 2 ^n^ 个片选信号。（3-8译码器：输入 3 个信号，输出 8 个信号）

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240623182437491.png" alt="image-20240623182437491" style="zoom:30%;" />

#### 主存容量扩展 —— 字位同时扩展

![image-20240623182842856](C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240623182842856.png)

将前面两种方式，字扩展和位扩展结合即可得到该图。

#### 总结

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240623183024488.png" alt="image-20240623183024488" style="zoom:40%;" />



### 3.4.1 磁盘存储器

#### 外存储器

计算机的外存储器又称为辅助存储器，目前主要使用磁表面存储器。

所谓 “ 磁表面存储 ” ，是指吧某些磁性材料薄薄的涂在金属铝或塑料表面上作为载磁体来存储信息。磁盘存储器，磁盘存带器和磁鼓存储器均属于磁表面存储器。

磁表面存储器的优点：

1. 存储容量大，位价格低
2. 记录介质可以重复使用
3. 记录信息可以长期保存而不丢失，甚至可以脱机存档
4. 非破坏性读出，读出时不需要再生

磁表面存储器的缺点：

1. 存取速度慢
2. 机械结构复杂
3. 对工作环境要求较高

外存储器既可以作为输入设备，也可以作为输出设备（既可以存数据，也可以读数据）

#### 磁盘存储器

##### 磁盘设备的组成

1. 存储区域：一块硬盘有若干个记录面，某个记录面划分为若干条磁道，而每条磁道又划分为若干个扇区，扇区（也成为块）是磁盘读写的最小单位，也就是说磁盘按块存取。

   <img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240623185116846.png" alt="image-20240623185116846" style="zoom:50%;" />

2. 硬盘存储器：

   硬盘存储器由硬盘驱动器、磁盘控制器和盘片组成。

   磁盘驱动器：核心部件是磁头组件和盘片组件，温彻斯特盘是一种可移动头固定盘片的硬盘存储器

   磁盘控制器：是磁盘存储器和主机的接口，主流的标准有：IDE、SCSI、SATA等

##### 磁盘的性能指标

1. 磁盘的容量：一个磁盘所能存储的字节总数称为磁盘容量。磁盘容量有非格式化容量和格式化容量之分。

     非格式化容量是指磁记录表面可以利用的磁化单元总数；

     格式化容量是指按照某种特定的记录格式所能存储信息的总量。

2. 记录密度：记录密度是指盘片单位面积上记录的二进制的信息量，通常以道密度、位密度和面密度表示。

     道密度是沿磁盘半径方向单位长度上的磁道数；

     位密度是磁道单位长度上能记录的二进制代码位数；

     面密度是位密度和道密度的乘积。

     注意：磁盘所有磁道记录的信息量一定是相等的，并不是圆越大信息越多，故每个磁道的位密度都不同。

3. **平均存取时间（常考）**

     **平均存取时间 = 寻道时间（磁头移动到目的磁道）+ 旋转延迟时间（磁盘定位到所在扇区）+ 传输时间（传输数据所花费的时间）。**

4. 数据传输率：磁盘存储器在单位时间内向主机传送数据的字节数，称为数据传输率。

     假设磁盘转数为 r （转 / 秒），每条磁道容量为 N 个字节，则数据传输率为 D~r~ = r * N 。

##### 磁盘地址

主机向磁盘控制器发送寻址信息，磁盘的地址一般如图所示：

|        驱动编号        |   柱面（磁道）号   |    盘面号    |             扇区号             |
| :--------------------: | :----------------: | :----------: | :----------------------------: |
| 一台电脑可能有多个硬盘 | 移动磁头臂（寻道） | 激活某个磁头 | 通过旋转将特定扇区划过磁头下方 |

##### 磁盘的工作过程

磁盘的主要操作是寻址、读盘、写盘，每个操作都对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字。

硬盘属于机械式部件，其读写操作是串行的，不可能在同一时刻既读又写，也不可能在同一时刻读两组数据或写两组数据。

#### 磁盘阵列

RAID（廉价冗余磁盘阵列）是将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上分割交叉存储、并行访问，具有更好的存储性能、可靠性和安全性。

RAID的分级如下所示。在 RAID1 ~ RAID5 的几种方案中，无论何时又磁盘损坏，都可以随时拔出受损的磁盘再插入好的磁盘，而数据不会损坏。

- RAID0：无冗余和无校验的磁盘阵列。（逻辑上相邻的两个扇区在物理上存到两个磁盘，类比之前的 “ 低位交叉编址的多体存储器 ” ）。RAID0 把连续多个数据块交替地存放在不同物理磁盘的扇区中，几个磁盘交叉并行读写，不仅扩大了存储容量，而且提高了磁盘数据存取速度，但是 RAID0 没有容错能力。
- RAID1：镜像磁盘阵列。（存放两份数据）RAID1 是为了提高可靠性，使两个磁盘同时进行读写，互为备份，如果一个磁盘出现故障，可以从另一个磁盘中读出数据，两个磁盘当一个磁盘使用，意味着容量减少一半。
- RAID2：采用纠错的海明码的磁盘阵列。（逻辑上连续的几个 bit 物理上分散存储在各个盘中，4 bit 信息位 + 3 bit 海明校验位 —— 可纠正一位错）
- RAID3：位交叉奇偶校验的磁盘阵列。
- RAID4：块交叉奇偶校验的磁盘阵列。
- RAID5：无独立校验的奇偶校验的磁盘阵列。

从上至下越往后可靠性越高，安全性也越好。RAID 通过

同时使用多个磁盘，提高了传输率；通过在多个磁盘上并行存取来大幅提高存储系统的数据吞吐量；通过镜像功能，可以提高安全性；提高数据校验，可以提供容错能力。

#### 总结

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240623193109069.png" alt="image-20240623193109069" style="zoom:35%;" />



### 3.4.2 固态硬盘

#### 原理及特性

固态硬盘基于闪存技术 Flash Memory ，属于电可擦除 ROM，即 EEPROM。

固态硬盘由多个**闪存芯片**作为存储介质，每个芯片包含多个块，每个块包含多个页。

固态硬盘**以页为单位进行读写，以块为单位进行擦除**，擦干净的块，其中的每一页都可以写一次，读无限次。

读快，写慢。如果要写的页有数据，则不能写入，需要将块内其它页全部复制到一个新的（擦除过的）块中，再写入新的页。

固态硬盘支持随机访问，系统给定一个逻辑地址，闪存翻译层可通过电路迅速定位到对应的物理地址。

#### 固态硬盘与机械硬盘

固态硬盘的读写速度块，随机访问性能高，用电路控制访问位置；机械硬盘通过移动磁臂旋转磁盘控制访问地址，有寻道时间和旋转延迟。

固态硬盘安静无噪音、耐摔抗震、能耗低、造假更贵。

**固态硬盘的一个 “ 块 ” 被擦除次数过多（重复写同一个块），可能会导致其损坏；而机械硬盘的扇区不会因为写的次数太多而坏掉。**

#### 磨损均衡技术

思想：将 “ 擦除 ” 平均分布在各个块上，以提升使用寿命。

动态磨损均衡技术：写入数据时，优先选择累计擦除次数少的新闪存块。

静态磨损均衡技术：SSD 监测并自动进行数据分配、迁移，让老旧的闪存块承担以读为主的储存任务，让较新的闪存块承担更多的写任务。

#### 总结

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240624183448238.png" alt="image-20240624183448238" style="zoom:35%;" />



### 3.5.1 Cache的基本概念和原理

Cache 被集成在 CPU 内部，而且 Cache 用 SRAM 实现，速度快，成本高。

#### 局部性原理

空间局部性：在最近的未来要用到的信息（指令和数据），很可能与现在正在使用的信息在存储空间上是邻近的。如：数组元素、顺序执行的指令代码。

时间局部性：在最近的未来要用到的信息，很可能是现在正在使用的信息。如：循环结构的指令代码。

基于局部性原理，不难想到，可以把 CPU 目前访问的地址 “ 周围 ” 的部分数据放到 Cache 中。

如何确定 “ 周围 ” ：将主存的存储空间分块，如 1 KB 为一块，主存与 Cache 之间以 “ 块 ” 为单位进行数据交换。

注意：操作系统中，通常也将主存中的 “ 一个块 ” 称为 “ 一个 页 / 页面 / 页框 ” ，Cache 中的 “ 块 ” 也成为 “ 行 ” 。

#### 性能分析

设 t~c~ 为访问一次 Cache 所需时间， t~m~ 为访问一次主存所需时间

命中率 H ：CPU 欲访问的信息已在 Cache 中的比率。缺失（未命中）率： M = 1 - H

Cache —— 主存 系统的平均访问时间 t 为： **t = H * t~c~ + (1 - H) * (t~c~ + t~m~)** （先访问 Cache ，若 Cache 未命中再访问主存）

或  **t = H * t~c~ + (1 - H) *  t~m~** （同时访问 Cache 和主存，若 Cache 命中则立即停止访问主存）。

#### 总结

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240624190921004.png" alt="image-20240624190921004" style="zoom:75%;" />



### 3.5.2 Cache - 主存的映射方式

#### 全相联映射

主存块可以放在 Cache 的任意位置

##### CPU 访问主存地址：

1. 主存地址的前 22 位，对比 Cache 中所有块的标记；
2. 若标记匹配且有效位 = 1，则 Cache 命中，访问相应块内地址的单元。
3. 若未命中或有效位 = 0，则正常访问主存

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240624193259295.png" alt="image-20240624193259295" style="zoom:30%;" />

#### 直接映射（只能放固定位置）

每个主存块只能放到一个特定位置： Cache 块号 = 主存块号 % Cache 总块数

缺点：其它地方有空闲 Cache 块，但是 8 号主存块不能使用

若 Cache 总块数 = 2^n^ ，则主存块号末尾 n 位直接反映它在 Cache 中的位置，我们只需要将主存块号的其余位作为标记即可。

##### CPU 访问主存地址：

1. 根据主存块号的后 3 位确定 Cache 行
2. 若主存块号的前 19 位与 Cache 标记匹配且有效位 = 1，则 Cache 命中，访问相应块内地址的单元
3. 若未命中或有效位 = 0，则正常访问主存

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240624194404142.png" alt="image-20240624194404142" style="zoom:30%;" />

#### 组相联映射（可放到特定分组）

Cache 块分为若干组，每个主存块可放到特定分组中的任意一个位置：组号 = 主存块号 % 分组数

2 路组相联映射 —— 两块为一组，分四组

主存块号 % 2^2^ ，相当于留下最后两位。

##### CPU 访问主存地址：

1. 根据主存块号的后 2 位确定所属分组号
2. 若主存块号的前 20 位与 Cache 标记匹配且有效位 = 1，则 Cache 命中，访问相应块内地址的单元
3. 若未命中或有效位 = 0，则正常访问主存

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240624194506820.png" alt="image-20240624194506820" style="zoom:30%;" />

#### 总结

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240624194645475.png" alt="image-20240624194645475" style="zoom:36%;" />



### 3.5.3 Cache替换算法

全相联映射：Cache 完全满了才需要替换，需要在全局选择替换哪一块

直接映射：如果对应位置非空，则毫无选择地直接替换（无需考虑替换算法）

组相联映射：分组内满了才需要替换，需要在分组内选择替换哪一块

#### 随机算法

若 Cache 已满，则随机选择一块替换

设总共有四个 Cache 块，初始化整个 Cache 为空，采用全相联映射，一次访问主存块 { 1，2，3，4，1，2，5，1，2，3，4，5 }

| 访问主存块 |   1   |   2   |   3   |   4   |   1   |   2   |   5   |   1   |   2   |   3   |   4   |   5   |
| :--------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|  Cache #0  | **1** |   1   |   1   |   1   | **1** |   1   |   1   | **1** |   1   |   1   | **4** |   4   |
|  Cache #1  |       | **2** |   2   |   2   |   2   | **2** |   2   |   2   | **2** |   2   |   2   |   2   |
|  Cache #2  |       |       | **3** |   3   |   3   |   3   | **5** |   5   |   5   |   5   |   5   | **5** |
|  Cache #3  |       |       |       | **4** |   4   |   4   |   4   |   4   |   4   | **3** |   3   |   3   |
| Cache 命中 |  否   |  否   |  否   |  否   |  是   |  是   |  否   |  是   |  是   |  否   |  否   |  是   |
| Cache 替换 |  否   |  否   |  否   |  否   |  否   |  否   |  是   |  否   |  否   |  是   |  是   |  否   |

随机算法 —— 实现简单，但完全**没有考虑局部性原理**，命中率低，实际效果很不稳定。

#### 先进先出算法（FIFO）

若 Cache 已满，则替换最先被调入 Cache 的块

设总共有四个 Cache 块，初始化整个 Cache 为空，采用全相联映射，一次访问主存块 { 1，2，3，4，1，2，5，1，2，3，4，5 }

| 访问主存块 |   1   |   2   |   3   |   4   |   1   |   2   |   5   |   1   |   2   |   3   |   4   |   5   |
| :--------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|  Cache #0  | **1** |   1   |   1   |   1   | **1** |   1   | **5** |   5   |   5   |   5   | **4** |   4   |
|  Cache #1  |       | **2** |   2   |   2   |   2   | **2** |   2   | **1** |   1   |   1   |   1   | **5** |
|  Cache #2  |       |       | **3** |   3   |   3   |   3   |   3   |   3   | **2** |   2   |   2   |   2   |
|  Cache #3  |       |       |       | **4** |   4   |   4   |   4   |   4   |   4   | **3** |   3   |   3   |
| Cache 命中 |  否   |  否   |  否   |  否   |  是   |  是   |  否   |  否   |  否   |  否   |  否   |  否   |
| Cache 替换 |  否   |  否   |  否   |  否   |  否   |  否   |  是   |  是   |  是   |  是   |  是   |  是   |

先进先出算法 —— 实现简单，最开始按 #0 #1 #2 #3 放入 Cache ，之后轮流替换 #0 #1 #2 #3 。

FIFO 算法依旧**没考虑局部性原理**，最先被调入 Cache 的块也有可能是被频繁访问的。

抖动现象：频繁的换入换出现象（刚被替换的块很快又被调入）

#### 近期最少使用算法（LRU）

为每一个 Cache 块设置一个 “ 计数器 ” ，用于记录每个 Cache 块已经多久没被访问了，当 Cache 满后替换 “ 计数器 ” 最大的。

设总共有四个 Cache 块，初始化整个 Cache 为空，采用全相联映射，一次访问主存块 { 1，2，3，4，1，2，5，1，2，3，4，5 }

| 访问主存块 |   1   |   2   |   3   |   4   |   1   |   2   |   5   |   1   |   2   |   3   |   4   |   5   |
| :--------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|  Cache #0  | **1** |   1   |   1   |   1   | **1** |   1   |   1   | **1** |   1   |   1   |   1   | **5** |
|  Cache #1  |       | **2** |   2   |   2   |   2   | **2** |   2   |   2   | **2** |   2   |   2   |   2   |
|  Cache #2  |       |       | **3** |   3   |   3   |   3   | **5** |   5   |   5   |   5   | **4** |   4   |
|  Cache #3  |       |       |       | **4** |   4   |   4   |   4   |   4   |   4   | **3** |   3   |   3   |
| Cache 命中 |  否   |  否   |  否   |  否   |  是   |  是   |  否   |  是   |  是   |  否   |  否   |  否   |
| Cache 替换 |  否   |  否   |  否   |  否   |  否   |  否   |  是   |  否   |  否   |  是   |  是   |  是   |

添加一个计数器，具体规则如下：

1. 命中时，所命中的计数器清零，**比其低的计数器加 1 ，其余不变**
2. 非命中且还有空闲行时，新装入的行的计数器置为 0 ，其余非空闲行全加 1 
3. 非命中且无空闲行时，计数值最大的行的信息块被淘汰，新装入的块的计数器置为 0 ，其余全加 1 

注意：计数器的值只可能出现 { 0、1、2、3 } 。原因就是第一条规则。这样，在 Cache 块的总数 = 2^n^ ，则计数器只需要 n 位，且 Cache 装满之后所有计数器的值一定是不重复的。

LRU 算法 —— 基于 “ 局部性 ” 原理，近期被访问过的主存块，在不久的将来也很有可能被再次访问，因此淘汰最久没被访问过的块是合理的。LRU 算法的实际运行效果优秀， Cache 命中率高。

若被频繁访问的主存块数量  >  Cache 行的数量，则也可能发生抖动，如：{ 1、2、3、4、5、1、2、3、4、5 … }

#### 最不经常使用算法（LFU）

为每一个 Cache 块设置一个 “ 计数器 ” ，用于记录每个 Cache 块被访问过几次，当 Cache 满后替换 “ 计数器 ” 最小的。

添加一个计数器，具体规则如下：

1. 新调入的块计数器 = 0，之后没被访问一次计数器加 1 ，需要替换时，选择计数器最小的一行
2. 若有多个计数器最小的行，可按行号递增，或FIFO策略进行选择。

| 访问主存块 |   1   |   2   |   3   |   4   |   1   |   2   |   5   |   1   |   2   |   3   |   4   |   5   |
| :--------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|  Cache #0  | **1** |   1   |   1   |   1   | **1** |   1   |   1   | **1** |   1   |   1   |   1   |   1   |
|  Cache #1  |       | **2** |   2   |   2   |   2   | **2** |   2   |   2   | **2** |   2   |   2   |   2   |
|  Cache #2  |       |       | **3** |   3   |   3   |   3   | **5** |   5   |   5   | **3** |   3   | **5** |
|  Cache #3  |       |       |       | **4** |   4   |   4   |   4   |   4   |   4   |   4   | **4** |   3   |
| Cache 命中 |  否   |  否   |  否   |  否   |  是   |  是   |  否   |  是   |  是   |  否   |  是   |  否   |
| Cache 替换 |  否   |  否   |  否   |  否   |  否   |  否   |  是   |  否   |  否   |  是   |  否   |  是   |

LFU 算法 —— 曾经被经常访问的主存块在未来不一定会被用到（如：微信视频聊天相关的块）

并没有很好地遵循局部性原理，因此实际运行效果不如 LRU

#### 总结

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240624205147727.png" alt="image-20240624205147727" style="zoom:35%;" />



### 3.5.4 Cache 写策略

#### 写命中

##### 写回法

当 CPU 对 Cache 写命中时，只修改 Cache 的内容，而不立即写入主存，只有当此块被换出时才写回主存。

由于未被修改过的内容不需要被写回，因此我们可以设置一个脏位来记录信息是否被修改过。

减少了访存次数，但是存在数据不一致的隐患。

##### 全写法（写直通法）

当 CPU 对 Cache 写命中时，必须把数据同时写入 Cache 和主存，一般使用写缓冲。

访问次数增加，速度变慢，但是更能够保证数据一致性。

使用写缓冲， CPU 写的速度很快，若写操作不频繁，则效果很好。若写操作很频繁，可能会因为写缓冲饱和而发生阻塞。

#### 写不命中

##### 写分配法

当 CPU 对 Cache 写不命中时，把主存中的块调入 Cache ，在 Cache 中修改。通常搭配**写回法**一同使用。

##### 非写分配法

当 CPU 对 Cache 写不命中时只写入主存，不调入 Cache。通常搭配**全写法**一同使用。

#### 多级Cache

现代计算机通常采用多级 Cache ：

离 CPU 越近的速度越快，容量越小；离 CPU 越远的速度越慢，容量越大。

各级 Cache 之间常采用 “ 全写法 + 非写分配法 ”

#### 总结

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240624210720840.png" alt="image-20240624210720840" style="zoom:35%;" />



### 3.6.1 页式存储器

页式存储系统：一个程序（进程）在逻辑上被分为若干个大小相等的 “ 页面 ” ， “ 页面 ” 大小与 “ 块 ” 的大小相同，每个页面可以离散地放入不同的主存块中。

逻辑地址（虚地址）：程序员视角看到的地址

物理地址（实地址）：实际在主存中的地址

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240624212058129.png" alt="image-20240624212058129" style="zoom:33%;" />

CPU 在执行的机器指令中，使用的是 “ 逻辑地址 ” ，因此需要通过 “ 页表 ” 将逻辑地址转为物理地址。

页表的作用：记录了每个逻辑页面存放在那个主存块中。

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240624212604048.png" alt="image-20240624212604048" style="zoom:33%;" />

快表是一种 “ 相联存储器 ” ，可以按照内容寻访。

快表中存储的是页表项的副本；Cache 中存储的是主存块的副本。

#### 总结

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240624212756828.png" alt="image-20240624212756828" style="zoom:80%;" />



### 3.6.2 虚拟存储器

#### 页式虚拟存储器

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240624214326480.png" alt="image-20240624214326480" style="zoom:33%;" />

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240624214221257.png" alt="image-20240624214221257" style="zoom:33%;" />

有效位：这个页面是否已调入主存

脏位：这个页面是否被修改过

引用位：用于 “ 页面置换算法 ” ，比如，可以用来统计这个页面被访问过多少次

物理页：即主存块号

磁盘地址：即这个页面的数据在磁盘中的存放位置

#### 存储器的层次化结构

主存 - 辅存：实现了虚拟存储系统，解决了主存容量不够的问题

Cache - 主存：解决了主存与 CPU 速度不匹配的问题

#### 段式虚拟存储器 —— 按照功能模块拆分

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240624214705158.png" alt="image-20240624214705158" style="zoom:80%;" />

#### 段页式虚拟存储器

把程序按逻辑结构分段，每段再划分位固定大小的页，主存空间页划分为大小相等的页，程序对主存的调入、调出仍以页为基本传送单位。

每个程序对应一个段表，每段对用一个页表。



## 四、指令系统

### 4.1.1 指令格式

#### 指令的定义

指令（又称为机器指令）：是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。

一台计算机的所有指令的集合构成该机的指令系统，也称为指令集。

注：**一台计算机只能执行自己指令系统中的指令，不能执行其它系统的指令。**

Eg：x86 架构、ARM架构

#### 指令格式

一条指令就是机器语言的一个语句，它是一组有意义的二进制代码。

一条指令通常要包括操作码字段和地址码字段两部分。

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240626152102557.png" alt="image-20240626152102557" style="zoom:90%;" />

一条指令可能包含 0 个、1 个、2 个、3 个、4 个地址码

根据地址码数目不同，可以将指令分为零地址指令、一地址指令、二地址指令

##### 零地址指令

|  OP  |
| :--: |

1. 不需要操作数，如空操作、停机、关中断等指令
2. 堆栈计算机，两个操作数隐含存放在栈顶和次栈顶，计算结果压回栈顶。

##### 一地址指令

|  OP  | A~1~ |
| :--: | :--: |

1. 只需要单操作数，如加1、减1、取反、求补等。										

   指令含义：OP(A~1~) —> A~1~ ，完成一条指令需要 3 次访存：取指 —> 读 A~1~ —> 写 A~1~

2. 需要两个操作数，但其中一个操作数隐含在某个寄存器（如隐含在 ACC）

   指令含义：(ACC)OP(A~1~) —> ACC。完成一条指令需要两次访存：取指 —> 读 A~1~

   注：A~1~ 指某个主存地址，(A~1~) 表示 A~1~ 所指向的地址中的内容

##### 二地址指令

|  OP  | A~1~ | A~2~ |
| :--: | :--: | :--: |

常用于需要两个操作数的算术运算、逻辑运算相关指令

指令含义：(A~1~)OP(A~2~) —> A~1~

完成一条指令需要访存 4 次，取指 —> 读A~1~ —> 读A~2~ —> 写A~1~

##### 三地址指令

|  OP  | A~1~ | A~2~ | A~3~(结果) |
| :--: | :--: | :--: | :--------: |

常用于需要两个操作数的算术运算、逻辑运算相关指令

指令含义：(A~1~)OP(A~2~) —> A~3~

完成一条指令需要访存 4 次，取指 —> 读A~1~ —> 读A~2~ —> 写A~3~

##### 四地址指令

|  OP  |  A1  |  A2  | A3(结果) | A4(下指) |
| :--: | :--: | :--: | :------: | :------: |

指令含义：(A~1~)OP(A~2~) —> A~3~ ，A~4~ = 下一条将要执行指令的地址

完成一条指令需要访存 4 次，取指 —> 读A~1~ —> 读A~2~ —> 写A~3~

正常情况下：取指令之后 PC + 1 ，指向下一条指令

四地址指令：指令执行后，将 PC 的值修改为 A~4~ 所指地址

**若指令总长度固定不变，则地址码数量越多，寻址能力越差**

#### 指令 —— 按指令长度分类

指令字长：一条指令的总长度（可能会变）

机器字长：CPU 进行一次整数运算所能处理的二进制数据的位数（通常与 ALU 总结相关）

存储字长：一个存储单元中二进制代码的位数（通常与 MDR 位数相同）

指令字长会影响取指令的时间，比如：机器字长 = 存储字长 = 16 bit ，则取一条双子长指令需要两次访存

定长指令字结构：指令系统中所有指令的长度都相等

变长指令字结构：指令系统中所有指令的长度不等

#### 指令 —— 按操作码长度分类

定长操作码：指令系统中所有指令的操作码长度都相同（控制器的译码电路设计简单，但是灵活性较低）

可变长操作码：指令系统中各指令的操作码长度可变（控制器的译码电路设计复杂，但是灵活度较高）

定长指令字结构 + 可变长操作码 —> 扩展操作码指令格式

#### 指令 —— 按操作类型分类

1. 数据传送：

   LOAD 作用：把存储器中的数据放到寄存器中

   STORE 作用：把寄存器中的数据放到存储器中

2. 算术逻辑操作

   算术：加减乘除，增1，减1，求补，浮点运算，十进制运算

   逻辑：与，或，非，异或，位操作，位测试，位清除，位求反

3. 移位操作

   算术移位，逻辑移位，循环移位

4. 转移操作

   无条件转移 JMP

   条件转移 JZ：结果为 0，JO：结果溢出，JC：结果有进位

   调用和返回 CALL和 RETURN

   陷阱（Trap）与陷阱指令

5. 输入输出操作

   CPU寄存器与IO端口之间的数据传送（端口IO接口中的寄存器）

#### 总结

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240626155330866.png" alt="image-20240626155330866" style="zoom:90%;" />



### 4.1.2 扩展操作码指令格式

#### 扩展操作码

1. 指令字长为 16 位，每个地址码占 4 位，前 4 位为基本操作码字段 OP ，另有 3 个 4 位长的地址字段 A~1~ 、A~2~ 和 A~3~ 
2. 4 位基本操作码若全部用于三地址指令，则有 16 条。
3. 但至少须将 1111 留作扩展操作码之用，即三地址指令为 15 条。
4. 1111 1111 留作扩展操作码之用，二地址指令为 15 条。
5. 1111 1111 1111 留作扩展操作码之用，一地址指令为 15 条。
6. 零地址指令为 16 条。

以上只是一种扩展操作码的设计方法，我们还有其它的设计方法。

在设计扩展操作码指令格式时，必须注意以下两点：

- 不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分的代码相同。
- 各指令的操作码一定不能重复。

通常情况下，对使用频率较高的指令，分配较短的操作码，对使用频率较低的指令，分配较长的操作码，从而尽可能减少指令译码和分析的时间。

例题：

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240626200825070.png" alt="image-20240626200825070" style="zoom:80%;" />

#### 总结

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240626201318399.png" alt="image-20240626201318399" style="zoom:35%;" />



### 4.2.1 指令寻址

#### 指令寻址

下一条欲执行的地址（始终由程序计数器 PC 给出）

##### 顺序寻址

(PC) + “ 1 ” —> PC ， 这里的 1 理解为 1 个指令字长，实际加的值会因为指令长度、编址的方式而不同

##### 跳跃寻址

**由转移指令指出**。

每次取指令之后，PC 自动加 1 ，指向下一条应该执行的指令。

#### 总结

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240626202512581.png" alt="image-20240626202512581" style="zoom:85%;" />



### 4.2.2 数据寻址

假设指令字长 = 机器字长 = 存储子长，操作数为 3 

一地址指令：

| 操作码（OP） | 寻址特征位 | 形式地址A |
| :----------: | :--------: | :-------: |



#### 直接寻址

直接寻址：指令字中的形式地址 A 就是操作数的真实地址 EA ，即 EA = A 。

![image-20240626203636727](C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240626203636727.png)

一条指令的执行：取指令访存 1 次，执行指令访存 1 次，暂不考虑存结果，共访存 2 次

优点：简单，指令执行阶段仅访问一次主存，不需要专门计算操作数的地址。

缺点：A的位数决定了该指令操作数的寻址范围。操作数的地址不易修改。

#### 间接寻址

间接寻址：指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址所在的存储单元的地址，也就是操作数地址的地址，即 EA = (A)。

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240626204403717.png" alt="image-20240626204403717" style="zoom:80%;" />

一条指令的执行：取指令访存 1 次，执行指令访存 2 次，暂不考虑存结果，共访存 3 次

优点：可扩大寻址范围（有效地址 EA 的位数大于形式地址 A 的位数）。

​	  便于编制程序（用间接寻址可以方便地完成子程序返回）。

缺点：指令在执行阶段要多次访存（一次间接寻址需要两次访存，多次寻址需要根据存储字的最高位确定几次访存）。

#### 寄存器寻址

寄存器寻址：在指令字中直接给出操作数所在的寄存器编号，即 EA = R~i~ ，其操作数在由 R~i~ 所指的寄存器内。

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240626205743964.png" alt="image-20240626205743964" style="zoom:90%;" />

一条指令的执行：取指令访存 1 次，执行指令访存 0 次，暂不考虑存结果，共访存 1 次。

优点：指令在执行阶段不访问主存，只访问主存，只访问寄存器，指令字短且执行速度快，支持向量 / 矩阵运算。

缺点：寄存器价格昂贵，计算机中寄存器个数有限。

#### 寄存器间接寻址

寄存器间接寻址：寄存器 R~i~ 中给出的不是一个操作数，而是操作数所在主存单元的地址，即 EA = ( R~i~ )

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240626214421222.png" alt="image-20240626214421222" style="zoom:50%;" />

一条指令的执行：取指令访存 1 次，执行指令访存 1 次，暂不考虑存结果，共访存 2 次。

特点：比一般间接寻址相比速度更快，但指令的执行阶段需要访问主存（因为操作数在主存中）。

#### 隐含寻址

隐含寻址：不是明显地给出操作数的地址，而是在指令中隐含着操作数的地址。

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240626214728578.png" alt="image-20240626214728578" style="zoom:50%;" />

优点：有利于缩短指令字长

缺点：需要增加存储操作数或隐含地址的硬件。

#### 立即寻址

立即寻址：形式地址 A 就是操作数本身，又称为立即数，一般采用补码形式。# 表示立即寻址特征。

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240626215406825.png" alt="image-20240626215406825" style="zoom:60%;" />

一条指令的执行：取指令访存 1 次，执行指令访存 0 次，暂不考虑存结果，共访存 1 次。

优点：指令执行阶段不访问主存，指令执行时间最短。

缺点：A 的位数限制了立即数的范围。 A 的位数为 n ，且立即数采用补码时，可表示的数据范围为 -2^n-1^ ~ 2^n-1^ - 1

#### 总结

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240626220241143.png" alt="image-20240626220241143" style="zoom:50%;" />



### 4.2.3 数据寻址2（偏移寻址）

基址寻址：以程序的起始存放地址作为 “ 起点 ” 。EA = (BR) + A

变址寻址：程序员自己决定从哪里作为 “ 起点 ” 。EA = (IX) + A

相对寻址：以程序计数器 PC 所指地址作为 “ 起点 ” 。EA = (PC) + A

#### 基址寻址

基址寻址：将 CPU 中的基址寄存器（BR）的内容加上指令格式中的形式地址 A ，而形成操作数的有效地址，即 EA = (BR) + A

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240626220957871.png" alt="image-20240626220957871" style="zoom:60%;" />

优点：便于程序 “ 浮动 ” ，方便实现多道程序并发运行。

​	   可扩大寻址范围（基址寄存器的位数大于形式地址 A 的位数）；用户不必考虑自己的程序存于主存的那一空间区域，故有利于		  多道程序设计，以及可用于编制浮动程序（整个程序在内存里边的浮动）。

注：基址寄存器是**面向操作系统**的，其**内容由操作系统或管理程序确定**，在程序执行过程中，基址寄存器的内容不变（作为基地址），形式地址可变（作为偏移量）。当采用通用寄存器作为基址寄存器时，可由**用户决定那个寄存器作为基址寄存器**，但其**内容仍由操作系统确定**。

#### 变址寻址

变址寻址：有效地址 EA 等于指令字中的形式地址 A 与变址寄存器 IX 的内容相加之和，即 EA = (IX) + A ，其中 IX 可为变址寄存器（专用），也可用通用寄存器作为变址寄存器。

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240626222449320.png" alt="image-20240626222449320" style="zoom:80%;" />

注：变址寄存器是**面向用户的**，在程序执行过程中，**变址寄存器的内容可由用户改变**（IX 作为偏移量），形式地址 A 不变（作为基地址）。

优点：在数组处理过程中，可设定 A 为数组的首地址，不断改变变址寄存器 IX 的内容，便可以很容易形成数组中任意数据的地址，**特别适合编制循环程序**。

#### 相对寻址

相对寻址：把程序计数器 PC 的内容加上指令格式中的形式地址 A 而形成操作数的有效地址，即 EA = (PC) + A，其中 A 是相对于 PC 所指地址的位移量，可正可负，补码表示。

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240626224112692.png" alt="image-20240626224112692" style="zoom:50%;" />

优点：操作数的地址不是固定的，它随着 PC 值的变化而变化，并且与指令地址之间总是相差一个固定值，因此便于程序浮动（一段代码在程序内部的浮动）。

相对寻址广泛用于转移指令。

重要：取出当前指令后， PC 会指向下一条指令，相对寻址是相对于下一条指令的偏移。



### 4.2.4 堆栈寻址

堆栈寻址：操作数存放在堆栈中，隐含使用堆栈指针（SP）作为操作数地址。

堆栈式存储器（或专用寄存器组）中一块特定的按 “ 后进先出 ”（LIFO）原则管理的存储区，该存储区中被读 / 写单元的地址式用一个特定的寄存器给出的，该寄存器称为堆栈指针（SP）。

硬堆栈不访存，软堆栈需要访存 1 次。



### 4.4 CISC 和 RISC

#### CISC（复杂指令集）

设计思路：一条指令完成一个复杂的基本功能。

代表：x86架构，主要用于笔记本，台式机。

80 - 20 规律：典型程序中 80 % 的语句仅仅使用处理机中 20 % 的指令。

#### RISC（精简指令集）

设计思路：一条指令完成一个基本 “ 动作 ” ，多条指令组合完成一个复杂的基本功能。

代表：ARM 架构，主要用于手机、平板。

#### 对比

设计一套能实现整数、矩阵 加 / 减 / 乘 运算的指令集：

CISC 的设计思路：除了提供整数的加减乘指令之外，还提供矩阵的加法指令，减法指令，乘法指令。每一条指令可以由一个专门的电路完成。

​	有的复杂指令用纯硬件实现很困难 —> 采用 “ 存储程序 ” 的设计思想，由一个比较通用的电路配合存储部件完成一条指令。

RISC 的设计思路：只提供整数的加减乘指令。一条指令一个电路，电路设计相对简单，功耗更低。更方便实现 “ 并行 ” 和 “ 流水线 ”

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240627112435477.png" alt="image-20240627112435477" style="zoom:46%;" />



## 五、中央处理器

### 5.1 CPU的功能和基本结构

#### CPU 的功能

1. 指令控制。完成取指令、分析指令和执行指令的操作，即程序的顺序控制。
2. 操作控制。一条指令的功能往往是由若干操作信号的组合来实现的。CPU 管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作。
3. 时间控制。对各种操作加以时间上的控制。时间控制要为每条指令按时间顺序提供应有的控制信号。
4. 数据加工。对数据进行算术运算和逻辑运算。
5. 中断处理。对计算机运行过程中出现的异常情况和特殊情况请求进行处理。

#### 运算器和控制器的功能

运算器：对数据进行加工

控制器：协调并控制计算机各部件执行程序的指令序列，基本功能包括取指令、分析指令、执行指令

​	取指令：自动形成指令地址，自动发出取指令的命令

​	分析指令：操作码译码（分析本条指令要完成什么操作）；产生操作数的有效地址。

​	执行指令：根据分析指令得到的 “ 操作命令 ” 和 “ 操作数地址 ” ，形成操作信号控制序列，控制运算器、存储器以及 I / O 设备完				  成相应的操作。

​	中断处理：管理总线及输入输出，处理异常情况（如掉电）和特殊请求（如打印机请求打印一行字符）

#### 运算器的基本结构

1. 算术逻辑单元：主要功能是进行算术 / 逻辑运算
2. 通用寄存器组：如AX、BX、CX、DX、SP 等，用于存放操作数（包括源操作数、目的操作数及中间结果）和各种地址信息等。SP 是堆栈指针，用于只是栈顶的地址。
3. 暂存寄存器：用于暂存从主存读来的数据，这个数据不能存放在通用寄存器中，否则会破坏原有的内容。
4. 累加寄存器：它是一个通用寄存器，用于暂时存放 ALU 运算的结果信息，用于实现加法运算
5. 程序状态字寄存器（PSW）：保留由算术逻辑运算指令或测试指令的结果而建立的各种信息状态，如各种标志。PSW中的这些位参与并决定微操作的形成。
6. 移位器：对运算结果进行移位运算。
7. 计数器：控制乘除运算的操作结果。

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240627115112671.png" alt="image-20240627115112671" style="zoom:60%;" />

**专用数据通路方式：根据指令执行过程中的数据和地址的流动方向安排线路连接。**

如果直接用导线连接，相当于多个寄存器同时并且一直向 ALU 传输数据

- 解决方法 1 ：使用多路选择器，根据控制信号选择一路输出
- 解决方法 2 ： 使用三态门，可以控制每一路是否输出

性能较高，基本不存在数据冲突现象，但结构复杂，硬件量大，不易实现。

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240627135721139.png" alt="image-20240627135721139" style="zoom:50%;" />

**CPU 内部单总线方式：将所有寄存器的输入端和输出端都连接到一条公共的通路上。**

结构简单，容易实现，但数据传输存在较多冲突的现象，性能较低。

#### 控制器的基本结构

1. 程序计数器：用于指出下一条指令在主存中的存放地址。 CPU 就是根据 PC 的内容去主存中取指令的。因程序中指令（通常）是顺序执行的，所以 PC 有自增功能。
2. 指令寄存器：用于保存当前正在执行的那条指令。
3. 指令译码器：仅对操作码字段进行译码，向控制器提供特定的操作信号。
4. 微操作信号发生器：根据 IR 的内容（指令）、PSW 的内容（状态信息）及时序信号，产生控制整个计算机系统所需的各种控制信号，其结构有组合逻辑型和存储逻辑型两种。
5. 时序系统：用于产生各种时序信号，它们都是由统一时钟（CLOCK）分频得到。
6. 存储器地址寄存器：用于存放所要访问的主存单元的地址。
7. 存储器数据寄存器：用于存放向主存写入的信息或从主存中读出的信息。

#### CPU 的基本结构

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240627140820390.png" alt="image-20240627140820390" style="zoom:40%;" />

#### 总结

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240627141321735.png" alt="image-20240627141321735" style="zoom:40%;" />



### 5.2 指令周期的数据流

#### 指令周期

CPU 从主存中每取出并执行一条指令所需的全部时间。

指令周期常用若干机器周期来表示，机器周期又叫 CPU 周期

一个机器周期又包含若干时钟周期（也成为节拍、T周期或CPU时钟周期，它是CPU操作的最基本单位）

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240627220941360.png" alt="image-20240627220941360" style="zoom:75%;" />

每个指令周期数可以不等，每个机器周期内的节拍数也可以不等。

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240627225040871.png" alt="image-20240627225040871" style="zoom:60%;" />

#### 指令周期流程

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240627225344579.png" alt="image-20240627225344579" style="zoom:57%;" />

四个工作周期都有 CPU 访存操作，只是访存的目的不同。**取指周期是为了取指令，间址周期是为了取有效地址，执行周期是为了取操作数，中断周期是为了保存程序断点**。

#### 指令周期的数据流 —— 取指周期

1. 当前指令地址送至存储器地址寄存器，记作 (PC) —> MAR
2.  CU 发出控制信号，经控制总线传到主存，这里是读信号，记作：1 —> R
3. 将 MAR 所指主存中的内容经数据总线送入 MDR ，记作：M(MAR) —> MDR
4. 将 MDR 中的内容（此时是指令）送入 IR ，记作：(MDR) —> IR
5.  CU 发出控制信号，形成下一条指令地址，记作：(PC) + 1 —> PC

#### 指令周期的数据流 —— 间址周期

1. 将指令的地址码送入 MAR，记作：Ad(IR) —> MAR
2. CU 发出控制信号，启动主存做读操作，记作：1 —> R
3. 将 MAR 所指主存中的内容经数据总线送入 MDR ，记作：M(MAR) —> MDR
4. 将有效地址送至指令的地址码字段，记作：(MDR) —> Ad(IR)

#### 指令周期的数据流 —— 执行周期

执行周期的任务是根据 IR 中的指令字的操作码和操作数通过 ALU 操作产生执行结果。不同指令的执行周期操作不同，因此没有统一的数据流向。

#### 指令周期的数据流 —— 中断周期

中断：暂停当前任务区完成其它任务，为了能够恢复当前任务，需要保存断点。一般使用堆栈来保存断点，这里用 SP 表示栈顶地址，假设 SP 指向栈顶元素，进栈操作是先修改指针后存入数据

1. CU 控制将 SP 减一，修改后的地址送入 MAR ，记作：(SP) - 1 —> SP，(SP) —> MAR。本质上是将断电存入某个存储单元，假设其地址位 a ，故可记作：a —> MAR
2. CU 发出控制信号，启动主存做写操作，记作：1 —> W
3. 将断点（PC内容）送入 MDR，记作：(PC) —> MDR
4. CU 控制将中断服务程序的入口地址（由向量地址形成部件产生）送入 PC，记作：向量地址 —> PC

#### 指令执行方案

##### 单指令周期

对所有指令都选用相同的执行时间来完成，指令之间串行执行；指令周期取决于执行时间最长的指令的执行时间。

对于那些本来可以在更短时间内完成的指令，要使用这个较长的周期来完成，会降低整个系统的运行速度。

##### 多指令周期

对不同类型的指令选用不同的执行步骤来完成，指令之间串行执行，可选用不同个数的时钟周期来完成不同指令的执行过程。需要更复杂的硬件设计。

##### 流水线方案

在每一个时钟周期启动一条指令，尽量让多条指令同时运行，但各自处在不同的执行步骤中，指令之间并行执行。

#### 总结

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240627232140442.png" alt="image-20240627232140442" style="zoom:70%;" />



### 5.3.1数据通路 —— 单总线结构

内部总线是指同一部件，如 CPU 内部连接各寄存器及运算部件之间的总线

系统总线是指同一台计算机系统的各部件，如 CPU 、内存、通道和各类 I / O 接口间相互连接的总线。

#### 寄存器之间数据传送



#### 总结

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240628150812198.png" alt="image-20240628150812198" style="zoom:50%;" />



### 5.3.2 数据通路 —— 专用通路结构



#### 总结

<img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20240628150912451.png" alt="image-20240628150912451" style="zoom:50%;" />



### 5.4.1 硬布线控制器的设计



#### 总结

